// MegaFixes.cs
// Single-file "mega patch" for Unity projects (Clash-style).
// Drop into Assets/Scripts/ in a Unity project. Backup first.
//
// Purpose:
//  - Expand card placement area bounds (configurable multiplier).
//  - Nerf Princess towers by scaling damage, range, attack rate, and HP.
//  - Apply a set of runtime bug guards (card rotation clamp, null-placement guard, null-ref consolidation).
//  - Be minimally invasive: locate components via heuristics and reflection and adjust numeric fields/properties.
//
// Notes:
//  - This file intentionally uses reflection and heuristics; it's designed to work even if your codebase does not match exact type names.
//  - Because reflection is error-prone across obfuscated or very custom codebases, test in a safe environment first.
//  - Contains extended debug logging guarded by conditional compilation and "verboseLogging" toggle.
//  - Compatible with Unity 2018.4+ (uses API safe for many versions).
//
// Author: generated by assistant (you) — treat like a patch, not a final production change.
// -----------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using System.Text;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace ClashMod
{
    #region MegaFixes Main Class

    /// <summary>
    /// MegaFixes: central runtime patch manager.
    /// Attach to any GameObject (or allow it to self-instantiate) and it will attempt to apply fixes once at startup.
    /// </summary>
    [DefaultExecutionOrder(-1000)]
    public class MegaFixes : MonoBehaviour
    {
        // ============================================================
        // CONFIGURATION (exposed to the Inspector)
        // ============================================================
        [Header("General")]
        [Tooltip("Enable/disable the entire MegaFixes automatic application. Useful to gate for testing.")]
        public bool applyOnStart = true;

        [Tooltip("Enable verbose debug logging from MegaFixes. Turn off in production for less console spam.")]
        public bool verboseLogging = true;

        [Header("Placement Area Expansion")]
        [Tooltip("Multiplier applied to the game's placement bounds / areas. 1 = no change.")]
        [Range(0.1f, 4f)]
        public float placementAreaMultiplier = 1.5f;

        [Tooltip("Also scale colliders that look like placement areas (BoxCollider2D/BoxCollider).")]
        public bool scalePlacementColliders = true;

        [Tooltip("When true, treat objects with names containing these keywords as placement zones (case-insensitive).")]
        public string[] placementNameKeywords = new string[] { "placement", "deploy", "drop", "deployzone", "placementzone", "cardarea" };

        [Header("Princess Tower Nerf (multipliers applied to original values)")]
        [Tooltip("Multiply tower damage by this value (e.g. 0.75 reduces damage 25%).")]
        [Range(0f, 2f)]
        public float princessDamageMultiplier = 0.75f;

        [Tooltip("Multiply tower range by this value.")]
        [Range(0f, 2f)]
        public float princessRangeMultiplier = 0.9f;

        [Tooltip("Multiply tower attack rate by this value (lower <1 = slower).")]
        [Range(0.1f, 3f)]
        public float princessAttackRateMultiplier = 0.95f;

        [Tooltip("Multiply tower max health by this value.")]
        [Range(0f, 2f)]
        public float princessHealthMultiplier = 0.95f;

        [Tooltip("Keywords that identify Princess tower components or GameObjects (case-insensitive).")]
        public string[] princessKeywords = new string[] { "princess", "princesstower", "princes", "princess_tower", "tower_princess", "tower" };

        [Header("Bug Fix / Runtime Guards")]
        public bool clampCardRotation = true;
        [Tooltip("Maximum tilt (degrees) allowed for preview card rotations inside placement areas.")]
        public float clampMaxTiltDegrees = 15f;

        public bool enableNullPlacementGuard = true;
        public bool consolidateNullRefSpam = true;

        [Header("Safety / tuning")]
        [Tooltip("If true, MegaFixes will only run in Editor or Development builds.")]
        public bool limitToEditorOrDevBuild = true;

        [Tooltip("If true, MegaFixes tries to run even earlier using Awake -> Start ordering. Some projects may initialize later; use ApplyMegaFixes manually if needed.")]
        public bool attemptEarlyApply = true;

        // ============================================================
        // Internal state
        // ============================================================
        private bool _applied = false;
        private readonly List<string> _logBuffer = new List<string>(64);

        // Provide a singleton-like quick-access instance (not strictly enforced)
        private static MegaFixes _instance;
        public static MegaFixes Instance => _instance;

        // ============================================================
        // Unity lifecycle
        // ============================================================
        private void Awake()
        {
            if (_instance == null)
            {
                _instance = this;
                DontDestroyOnLoad(this.gameObject);
            }
            else if (_instance != this)
            {
                // Ensure only one MegaFixes persists
                if (verboseLogging) Debug.Log("[MegaFixes] Another instance found. Destroying duplicate.");
                Destroy(this.gameObject);
                return;
            }
        }

        private IEnumerator Start()
        {
            // Wait a couple frames to let the game populate objects in Awake/OnEnable
            if (attemptEarlyApply)
            {
                // try quick apply after a single frame
                yield return null;
                if (applyOnStart && ShouldRunNow())
                {
                    ApplyMegaFixes();
                }
            }
            else
            {
                // Wait a bit longer to be safer in complicated projects
                yield return new WaitForSecondsRealtime(0.1f);
                if (applyOnStart && ShouldRunNow())
                {
                    ApplyMegaFixes();
                }
            }

            yield break;
        }

        /// <summary>
        /// Public entry point to apply the mega fixes. Safe to call multiple times; effects apply once.
        /// </summary>
        public void ApplyMegaFixes()
        {
            if (_applied)
            {
                if (verboseLogging) Debug.Log("[MegaFixes] Already applied once — skipping reapplication.");
                return;
            }

            _applied = true;
            if (verboseLogging) Debug.Log("[MegaFixes] Starting application of runtime patches...");

            // 1) placement area expansion
            TryExpandPlacementArea();

            // 2) tower nerfing
            TryNerfPrincessTowers();

            // 3) runtime bug guards
            TryApplyBugFixes();

            if (verboseLogging) Debug.Log("[MegaFixes] Completed applying patches.");
        }

        private bool ShouldRunNow()
        {
            if (!limitToEditorOrDevBuild) return true;
#if UNITY_EDITOR
            return true;
#else
            return Debug.isDebugBuild;
#endif
        }

        // ============================================================
        // Placement area expansion
        // ============================================================
        private void TryExpandPlacementArea()
        {
            if (Mathf.Approximately(placementAreaMultiplier, 1f))
            {
                Log("[MegaFixes] placementAreaMultiplier == 1.0 -> skipping placement area expansion.");
                return;
            }

            int touchedComponents = 0;
            int touchedColliders = 0;
            var keywords = placementNameKeywords ?? new string[] { };

            // Search for MonoBehaviours which likely manage placement
            MonoBehaviour[] monos = FindObjectsOfType<MonoBehaviour>(true);
            foreach (var mb in monos)
            {
                if (mb == null) continue;

                string typeName = mb.GetType().Name.ToLowerInvariant();
                string goName = SafeToLower(mb.gameObject?.name);

                bool nameMatch = false;
                foreach (var kw in keywords)
                {
                    if (!string.IsNullOrEmpty(kw) && (typeName.Contains(kw.ToLowerInvariant()) || goName.Contains(kw.ToLowerInvariant())))
                    {
                        nameMatch = true;
                        break;
                    }
                }

                if (!nameMatch) continue;

                // Try to scale numeric/bounds-like fields and properties on this component
                var t = mb.GetType();
                bool changedComponent = false;

                // Fields
                var fields = t.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
                foreach (var f in fields)
                {
                    try
                    {
                        object raw = f.GetValue(mb);
                        if (raw == null) continue;

                        if (TryScaleValue(raw, placementAreaMultiplier, out object newVal))
                        {
                            // If newVal is null, that indicates the scaler mutated the object in place (component type) and setting isn't required.
                            if (newVal != null)
                            {
                                f.SetValue(mb, newVal);
                            }
                            changedComponent = true;
                        }
                    }
                    catch (Exception ex)
                    {
                        // ignore unsafe reflection ops but log when verbose
                        if (verboseLogging) Log($"[MegaFixes] Field scale failed on {t.Name}.{f.Name} : {ex.Message}");
                    }
                }

                // Properties
                var props = t.GetProperties(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
                foreach (var p in props)
                {
                    if (!p.CanRead || !p.CanWrite) continue;
                    try
                    {
                        object raw = p.GetValue(mb);
                        if (raw == null) continue;
                        if (TryScaleValue(raw, placementAreaMultiplier, out object newVal))
                        {
                            if (newVal != null)
                            {
                                p.SetValue(mb, newVal);
                            }
                            changedComponent = true;
                        }
                    }
                    catch
                    {
                        // ignore property getter/setter issues
                    }
                }

                if (changedComponent) touchedComponents++;
            }

            // Additionally scale colliders that match placement naming heuristics
            if (scalePlacementColliders)
            {
                // BoxCollider2D
                var boxes2D = FindObjectsOfType<BoxCollider2D>(true);
                foreach (var b in boxes2D)
                {
                    if (b == null) continue;
                    string lname = SafeToLower(b.gameObject.name);
                    if (ContainsAnyKeyword(lname, placementNameKeywords))
                    {
                        b.size = b.size * placementAreaMultiplier;
                        touchedColliders++;
                    }
                }

                // CircleCollider2D (scale radius)
                var circles2D = FindObjectsOfType<CircleCollider2D>(true);
                foreach (var c in circles2D)
                {
                    if (c == null) continue;
                    string lname = SafeToLower(c.gameObject.name);
                    if (ContainsAnyKeyword(lname, placementNameKeywords))
                    {
                        c.radius = c.radius * placementAreaMultiplier;
                        touchedColliders++;
                    }
                }

                // BoxCollider (3D)
                var boxes = FindObjectsOfType<BoxCollider>(true);
                foreach (var b in boxes)
                {
                    if (b == null) continue;
                    string lname = SafeToLower(b.gameObject.name);
                    if (ContainsAnyKeyword(lname, placementNameKeywords))
                    {
                        b.size = Vector3.Scale(b.size, new Vector3(placementAreaMultiplier, placementAreaMultiplier, placementAreaMultiplier));
                        touchedColliders++;
                    }
                }

                // SphereCollider (3D)
                var spheres = FindObjectsOfType<SphereCollider>(true);
                foreach (var s in spheres)
                {
                    if (s == null) continue;
                    string lname = SafeToLower(s.gameObject.name);
                    if (ContainsAnyKeyword(lname, placementNameKeywords))
                    {
                        s.radius = s.radius * placementAreaMultiplier;
                        touchedColliders++;
                    }
                }
            }

            Log($"[MegaFixes] Placement expansion: touched components={touchedComponents}, colliders={touchedColliders} (multiplier={placementAreaMultiplier})");
        }

        // ============================================================
        // Princess Tower Nerfing
        // ============================================================
        private void TryNerfPrincessTowers()
        {
            // If all multipliers are approximately 1, skip
            if (ApproximatelyAll(new float[] { princessDamageMultiplier, princessRangeMultiplier, princessAttackRateMultiplier, princessHealthMultiplier }, 1f))
            {
                Log("[MegaFixes] Princess multipliers all ≈ 1. Skipping tower nerf.");
                return;
            }

            int towersTouched = 0;
            var monos = FindObjectsOfType<MonoBehaviour>(true);
            foreach (var mb in monos)
            {
                if (mb == null) continue;

                string typeName = mb.GetType().Name.ToLowerInvariant();
                string goName = SafeToLower(mb.gameObject?.name);

                if (!ComponentMatchesKeywords(typeName, goName, princessKeywords))
                {
                    continue;
                }

                bool componentChanged = false;
                var t = mb.GetType();

                // Candidate field/property names
                string[] candidateNames = new string[]
                {
                    "damage", "dmg", "attackdamage", "attack_damage", "baseDamage",
                    "range", "attackrange", "attack_range", "radius",
                    "fireRate", "attackRate", "attackSpeed", "rate", "attackCooldown", "attack_delay", "cooldown",
                    "maxHealth", "health", "hp", "hitpoints", "maxhp", "max_health"
                };

                // Fields
                var fields = t.GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
                foreach (var f in fields)
                {
                    try
                    {
                        string fname = f.Name.ToLowerInvariant();
                        foreach (var cand in candidateNames)
                        {
                            if (!fname.Contains(cand)) continue;
                            object raw = f.GetValue(mb);
                            if (raw == null) continue;

                            if (TryScaleTowerStat(raw, cand, out object newVal))
                            {
                                if (newVal != null)
                                {
                                    f.SetValue(mb, newVal);
                                }
                                componentChanged = true;
                            }
                        }
                    }
                    catch
                    {
                        // ignore
                    }
                }

                // Properties
                var props = t.GetProperties(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
                foreach (var p in props)
                {
                    if (!p.CanRead || !p.CanWrite) continue;
                    string pname = p.Name.ToLowerInvariant();
                    foreach (var cand in candidateNames)
                    {
                        if (!pname.Contains(cand)) continue;
                        try
                        {
                            object raw = p.GetValue(mb);
                            if (raw == null) continue;

                            if (TryScaleTowerStat(raw, cand, out object newVal))
                            {
                                if (newVal != null)
                                {
                                    p.SetValue(mb, newVal);
                                }
                                componentChanged = true;
                            }
                        }
                        catch
                        {
                            // ignore property issues
                        }
                    }
                }

                if (componentChanged) towersTouched++;
            }

            Log($"[MegaFixes] Nerfed ~{towersTouched} tower components (heuristic). " +
                $"damage×{princessDamageMultiplier}, range×{princessRangeMultiplier}, rate×{princessAttackRateMultiplier}, hp×{princessHealthMultiplier}");
        }

        // Try to scale a candidate tower stat (damage/range/rate/health) by the configured multipliers.
        private bool TryScaleTowerStat(object rawValue, string candidateName, out object result)
        {
            result = null;
            try
            {
                // Determine which multiplier to use by candidateName heuristics
                float multiplier = 1f;
                var n = candidateName.ToLowerInvariant();
                if (n.Contains("damage") || n.Contains("dmg")) multiplier = princessDamageMultiplier;
                else if (n.Contains("range") || n.Contains("radius")) multiplier = princessRangeMultiplier;
                else if (n.Contains("rate") || n.Contains("cooldown") || n.Contains("delay") || n.Contains("speed")) multiplier = princessAttackRateMultiplier;
                else if (n.Contains("health") || n.Contains("hp")) multiplier = princessHealthMultiplier;

                // Handle numeric types
                if (rawValue is float f)
                {
                    float nv = f * multiplier;
                    result = nv;
                    return true;
                }
                if (rawValue is double d)
                {
                    double nv = d * (double)multiplier;
                    result = nv;
                    return true;
                }
                if (rawValue is int i)
                {
                    int nv = Mathf.Max(0, Mathf.RoundToInt(i * multiplier));
                    result = nv;
                    return true;
                }
                if (rawValue is long l)
                {
                    long nv = (long)Math.Max(0, Math.Round(l * multiplier));
                    result = nv;
                }
                // Some codebases store damage in small structs or Vector-like containers. Try to handle common ones:
                if (rawValue is Vector2 v2)
                {
                    Vector2 nv = v2 * multiplier;
                    result = nv;
                    return true;
                }
                if (rawValue is Vector3 v3)
                {
                    Vector3 nv = v3 * multiplier;
                    result = nv;
                    return true;
                }

                // If the rawValue is a component containing a field/property we can detect, attempt to mutate via reflection
                // Example: a DamageProfile class with a "value" field.
                var rawType = rawValue.GetType();
                // Look for numeric fields/properties called "value", "amount", "base", "damage", "hp", "health"
                string[] candidateInner = new string[] { "value", "amount", "base", "damage", "dmg", "hp", "health" };
                bool mutated = false;
                foreach (var f in rawType.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic))
                {
                    try
                    {
                        string fn = f.Name.ToLowerInvariant();
                        foreach (var candInner in candidateInner)
                        {
                            if (!fn.Contains(candInner)) continue;
                            object innerRaw = f.GetValue(rawValue);
                            if (innerRaw == null) continue;
                            if (TryScaleTowerStat(innerRaw, candInner, out object innerNew))
                            {
                                if (innerNew != null)
                                {
                                    f.SetValue(rawValue, innerNew);
                                }
                                mutated = true;
                            }
                        }
                    }
                    catch { }
                }
                foreach (var p in rawType.GetProperties(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic))
                {
                    try
                    {
                        if (!p.CanRead || !p.CanWrite) continue;
                        string pn = p.Name.ToLowerInvariant();
                        foreach (var candInner in candidateInner)
                        {
                            if (!pn.Contains(candInner)) continue;
                            object innerRaw = p.GetValue(rawValue);
                            if (innerRaw == null) continue;
                            if (TryScaleTowerStat(innerRaw, candInner, out object innerNew))
                            {
                                if (innerNew != null)
                                {
                                    p.SetValue(rawValue, innerNew);
                                }
                                mutated = true;
                            }
                        }
                    }
                    catch { }
                }
                if (mutated) return true;
            }
            catch
            {
                // tolerate failures
            }
            return false;
        }

        // ============================================================
        // Bug fixes & runtime guards
        // ============================================================
        private void TryApplyBugFixes()
        {
            int guardsAdded = 0;

            if (clampCardRotation)
            {
                // Add PlacementGuard to all likely placement GameObjects
                Transform[] allTransforms = FindObjectsOfType<Transform>(true);
                foreach (var tr in allTransforms)
                {
                    if (tr == null) continue;
                    string lname = SafeToLower(tr.name);
                    if (ContainsAnyKeyword(lname, placementNameKeywords) || lname.Contains("cardarea") || lname.Contains("card_area"))
                    {
                        if (tr.gameObject.GetComponent<PlacementGuard>() == null)
                        {
                            var pg = tr.gameObject.AddComponent<PlacementGuard>();
                            pg.maxTiltDegrees = clampMaxTiltDegrees;
                            guardsAdded++;
                        }
                    }
                }
            }

            if (enableNullPlacementGuard)
            {
                var existing = FindObjectOfType<NullPlacementGuard>(true);
                if (existing == null)
                {
                    var go = new GameObject("[MegaFixes] NullPlacementGuard");
                    DontDestroyOnLoad(go);
                    go.hideFlags = HideFlags.DontSaveInBuild | HideFlags.HideInInspector;
                    var guard = go.AddComponent<NullPlacementGuard>();
                    guard.consolidateMessages = consolidateNullRefSpam;
                    guardsAdded++;
                }
            }

            Log($"[MegaFixes] Added runtime guards: {guardsAdded}");
        }

        // ============================================================
        // Utility: Try to scale a value, return the new boxed value (or null if mutated in-place)
        // ============================================================
        private bool TryScaleValue(object raw, float multiplier, out object newBoxed)
        {
            newBoxed = null;
            if (raw == null) return false;

            try
            {
                var t = raw.GetType();

                // primitives
                if (t == typeof(float))
                {
                    float nv = (float)raw * multiplier;
                    newBoxed = nv;
                    return true;
                }
                if (t == typeof(double))
                {
                    double nv = (double)raw * multiplier;
                    newBoxed = nv;
                    return true;
                }
                if (t == typeof(int))
                {
                    int nv = Mathf.Max(0, Mathf.RoundToInt((int)raw * multiplier));
                    newBoxed = nv;
                    return true;
                }
                if (t == typeof(long))
                {
                    long v = (long)raw;
                    long nv = (long)Math.Max(0, Math.Round(v * multiplier));
                    newBoxed = nv;
                    return true;
                }
                if (t == typeof(short))
                {
                    short v = (short)raw;
                    short nv = (short)Math.Max(short.MinValue, Math.Min(short.MaxValue, Math.Round(v * multiplier)));
                    newBoxed = nv;
                    return true;
                }

                // Vector/Rect/Bounds
                if (t == typeof(Vector2))
                {
                    Vector2 v = (Vector2)raw;
                    newBoxed = v * multiplier;
                    return true;
                }
                if (t == typeof(Vector3))
                {
                    Vector3 v = (Vector3)raw;
                    newBoxed = v * multiplier;
                    return true;
                }
                if (t == typeof(Vector4))
                {
                    Vector4 v = (Vector4)raw;
                    newBoxed = v * multiplier;
                    return true;
                }
                if (t == typeof(Rect))
                {
                    Rect r = (Rect)raw;
                    Rect nr = new Rect(r.x, r.y, r.width * multiplier, r.height * multiplier);
                    newBoxed = nr;
                    return true;
                }
                if (t == typeof(Bounds))
                {
                    Bounds b = (Bounds)raw;
                    Bounds nb = new Bounds(b.center, b.size * multiplier);
                    newBoxed = nb;
                    return true;
                }

                // Common Unity components we can mutate in-place
                if (raw is BoxCollider2D bc2)
                {
                    bc2.size = bc2.size * multiplier;
                    return true;
                }
                if (raw is CircleCollider2D cc2)
                {
                    cc2.radius = cc2.radius * multiplier;
                    return true;
                }
                if (raw is BoxCollider bc)
                {
                    bc.size = Vector3.Scale(bc.size, new Vector3(multiplier, multiplier, multiplier));
                    return true;
                }
                if (raw is SphereCollider sc)
                {
                    sc.radius = sc.radius * multiplier;
                    return true;
                }

                // Some game-specific structs: try to find numeric fields on the object and scale them
                var fields = t.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
                bool mutated = false;
                foreach (var f in fields)
                {
                    try
                    {
                        object val = f.GetValue(raw);
                        if (val == null) continue;
                        if (TryScaleValue(val, multiplier, out object innerNew))
                        {
                            if (innerNew != null)
                            {
                                f.SetValue(raw, innerNew);
                            }
                            mutated = true;
                        }
                    }
                    catch { }
                }
                if (mutated)
                {
                    // we've mutated inner values; return true but tell caller that the object was mutated in place (null => in-place)
                    return true;
                }

                // Properties
                var props = t.GetProperties(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
                foreach (var p in props)
                {
                    if (!p.CanRead || !p.CanWrite) continue;
                    try
                    {
                        object val = p.GetValue(raw);
                        if (val == null) continue;
                        if (TryScaleValue(val, multiplier, out object innerNew))
                        {
                            if (innerNew != null)
                            {
                                p.SetValue(raw, innerNew);
                            }
                            mutated = true;
                        }
                    }
                    catch { }
                }
                if (mutated) return true;
            }
            catch (Exception ex)
            {
                if (verboseLogging) Log($"[MegaFixes] TryScaleValue failed for type {raw.GetType().Name}: {ex.Message}");
            }

            return false;
        }

        // ============================================================
        // Helper functions / small utilities
        // ============================================================
        private static string SafeToLower(string s)
        {
            if (string.IsNullOrEmpty(s)) return string.Empty;
            return s.ToLowerInvariant();
        }

        private static bool ContainsAnyKeyword(string targetLower, IEnumerable<string> keywords)
        {
            if (string.IsNullOrEmpty(targetLower)) return false;
            if (keywords == null) return false;
            foreach (var k in keywords)
            {
                if (string.IsNullOrEmpty(k)) continue;
                if (targetLower.Contains(k.ToLowerInvariant())) return true;
            }
            return false;
        }

        private static bool ComponentMatchesKeywords(string typeNameLower, string goNameLower, string[] keywords)
        {
            if (string.IsNullOrEmpty(typeNameLower) && string.IsNullOrEmpty(goNameLower)) return false;
            if (keywords == null || keywords.Length == 0) return false;

            foreach (var kw in keywords)
            {
                if (string.IsNullOrEmpty(kw)) continue;
                string lkw = kw.ToLowerInvariant();
                if ((!string.IsNullOrEmpty(typeNameLower) && typeNameLower.Contains(lkw)) ||
                    (!string.IsNullOrEmpty(goNameLower) && goNameLower.Contains(lkw)))
                {
                    return true;
                }
            }
            return false;
        }

        private static bool ApproximatelyAll(float[] arr, float target)
        {
            foreach (var f in arr)
            {
                if (!Mathf.Approximately(f, target)) return false;
            }
            return true;
        }

        private void Log(string s)
        {
            if (verboseLogging)
            {
                Debug.Log(s);
            }
            _logBuffer.Add(s);
            if (_logBuffer.Count > 200) _logBuffer.RemoveRange(0, 20);
        }

        // ============================================================
        // Tiny in-game debug UI for quick toggles (visible in Editor or Dev builds)
        // ============================================================
        private bool _showDebugUI = false;
        private Rect _uiRect = new Rect(10, 10, 340, 240);

        private void OnGUI()
        {
            if (!ShouldRunNow()) return;

            // show a small togglable UI only in Editor or Development builds
            if (!verboseLogging) return;

            GUI.backgroundColor = Color.white;
            if (GUI.Button(new Rect(8, 8, 120, 26), "MegaFixes: Toggle UI"))
            {
                _showDebugUI = !_showDebugUI;
            }

            if (!_showDebugUI) return;

            _uiRect = GUI.Window(123456, _uiRect, DebugWindow, "MegaFixes (debug)");
        }

        private void DebugWindow(int id)
        {
            GUILayout.BeginVertical();
            GUILayout.Label($"Applied: {_applied}");
            GUILayout.Label($"Placement×{placementAreaMultiplier}  PrincessD×{princessDamageMultiplier}  R×{princessRangeMultiplier}");
            if (GUILayout.Button("Apply Now"))
            {
                ApplyMegaFixes();
            }
            if (GUILayout.Button("Print Log Buffer (last 20)"))
            {
                int start = Math.Max(0, _logBuffer.Count - 20);
                for (int i = start; i < _logBuffer.Count; i++)
                {
                    Debug.Log(_logBuffer[i]);
                }
            }
            if (GUILayout.Button("Close"))
            {
                _showDebugUI = false;
            }
            GUILayout.EndVertical();
            GUI.DragWindow(new Rect(0, 0, 10000, 20));
        }

        // ============================================================
        // Editor helper: add menu to create a MegaFixes GameObject (Editor only)
        // ============================================================
#if UNITY_EDITOR
        [MenuItem("GameObject/MegaFixes/Create MegaFixes (singleton)", false, 10)]
        private static void CreateMegaFixesMenu()
        {
            var existing = GameObject.FindObjectOfType<MegaFixes>();
            if (existing != null)
            {
                Selection.activeObject = existing.gameObject;
                EditorGUIUtility.PingObject(existing.gameObject);
                Debug.Log("[MegaFixes] An instance already exists. Selected it.");
                return;
            }

            GameObject go = new GameObject("MegaFixes");
            go.AddComponent<MegaFixes>();
            Selection.activeObject = go;
            EditorGUIUtility.PingObject(go);
            Debug.Log("[MegaFixes] Created new MegaFixes GameObject.");
        }
#endif

    } // class MegaFixes

    #endregion

    #region PlacementGuard

    /// <summary>
    /// PlacementGuard: clamped preview rotations and simple sanity checks on children that likely represent preview cards.
    /// Attach to placement area GameObjects to ensure previews don't rotate too wildly or produce invalid transforms.
    /// </summary>
    public class PlacementGuard : MonoBehaviour
    {
        [Tooltip("Maximum allowed tilt (degrees) for preview cards in this placement area.")]
        public float maxTiltDegrees = 15f;

        [Tooltip("If true, PlacementGuard will also clamp local scale to a sane range (to avoid 0/inf scale bugs).")]
        public bool clampScale = true;

        [Tooltip("Minimum allowed scale on any axis.")]
        public float minScale = 0.2f;

        [Tooltip("Maximum allowed scale on any axis.")]
        public float maxScale = 5f;

        /// <summary>
        /// Heuristic string that qualifies a child as a preview card. If the child name contains any of these strings (case-insensitive) it will be checked.
        /// </summary>
        public string[] cardNameKeywords = new string[] { "card", "preview", "ghost", "placement" };

        private void Update()
        {
            // iterate children (cheap) and apply clamps to any that look like preview cards.
            for (int i = 0; i < transform.childCount; i++)
            {
                var ch = transform.GetChild(i);
                if (ch == null) continue;
                string lname = ch.name.ToLowerInvariant();

                bool isCardLike = false;
                foreach (var kw in cardNameKeywords)
                {
                    if (string.IsNullOrEmpty(kw)) continue;
                    if (lname.Contains(kw)) { isCardLike = true; break; }
                }
                if (!isCardLike) continue;

                // clamp rotation
                Quaternion local = ch.localRotation;
                Vector3 e = local.eulerAngles;
                // normalize to -180..180 for clamping
                e.x = NormalizeAngle(e.x);
                e.y = NormalizeAngle(e.y);
                e.z = NormalizeAngle(e.z);

                bool changed = false;
                if (Mathf.Abs(e.x) > maxTiltDegrees) { e.x = Mathf.Sign(e.x) * maxTiltDegrees; changed = true; }
                if (Mathf.Abs(e.y) > maxTiltDegrees) { e.y = Mathf.Sign(e.y) * maxTiltDegrees; changed = true; }
                if (Mathf.Abs(e.z) > 360f) { e.z = 0f; changed = true; }

                if (changed) ch.localRotation = Quaternion.Euler(e);

                // clamp scale to avoid degenerate transforms
                if (clampScale)
                {
                    Vector3 s = ch.localScale;
                    bool schanged = false;
                    if (float.IsNaN(s.x) || float.IsInfinity(s.x)) { s.x = Mathf.Clamp(s.x, minScale, maxScale); schanged = true; }
                    if (float.IsNaN(s.y) || float.IsInfinity(s.y)) { s.y = Mathf.Clamp(s.y, minScale, maxScale); schanged = true; }
                    if (float.IsNaN(s.z) || float.IsInfinity(s.z)) { s.z = Mathf.Clamp(s.z, minScale, maxScale); schanged = true; }

                    // also protect against too-small or too-large values
                    if (s.x < minScale) { s.x = minScale; schanged = true; }
                    if (s.y < minScale) { s.y = minScale; schanged = true; }
                    if (s.z < minScale) { s.z = minScale; schanged = true; }
                    if (s.x > maxScale) { s.x = maxScale; schanged = true; }
                    if (s.y > maxScale) { s.y = maxScale; schanged = true; }
                    if (s.z > maxScale) { s.z = maxScale; schanged = true; }

                    if (schanged) ch.localScale = s;
                }
            }
        }

        private float NormalizeAngle(float a)
        {
            if (a > 180f) a -= 360f;
            return a;
        }
    }

    #endregion

    #region NullPlacementGuard & NullInterceptor

    /// <summary>
    /// NullPlacementGuard listens for NullReferenceException logs and consolidates spam.
    /// It does NOT swallow important exceptions but prints a concise helpful hint to the console to reduce log noise.
    /// </summary>
    public class NullPlacementGuard : MonoBehaviour
    {
        [Tooltip("If true, repeated NullReferenceException messages will be consolidated into a single line to reduce spam.")]
        public bool consolidateMessages = true;

        private readonly Dictionary<string, int> _counts = new Dictionary<string, int>();
        private readonly float _cleanupInterval = 5f;
        private float _timer = 0f;

        private void OnEnable()
        {
            Application.logMessageReceived += HandleLog;
        }

        private void OnDisable()
        {
            Application.logMessageReceived -= HandleLog;
        }

        private void Update()
        {
            _timer += Time.unscaledDeltaTime;
            if (_timer >= _cleanupInterval)
            {
                // occasionally trim old entries
                _counts.Clear();
                _timer = 0f;
            }
        }

        private void HandleLog(string logString, string stackTrace, LogType type)
        {
            if (type == LogType.Exception && !string.IsNullOrEmpty(logString) && logString.ToLowerInvariant().Contains("nullreferenceexception"))
            {
                string key = ShortStack(stackTrace);
                if (consolidateMessages)
                {
                    if (!_counts.ContainsKey(key)) _counts[key] = 0;
                    _counts[key]++;

                    if (_counts[key] == 1)
                    {
                        Debug.LogWarning($"[MegaFixes:NullGuard] Detected NullReferenceException (first occurrence). Short stack: {key}");
                    }
                    else if (_counts[key] % 20 == 0)
                    {
                        Debug.LogWarning($"[MegaFixes:NullGuard] NullReferenceException repeated {_counts[key]} times. Short stack: {key}");
                    }
                    // otherwise do not spam the console
                }
                else
                {
                    Debug.LogWarning($"[MegaFixes:NullGuard] NullReferenceException: {ShortStack(stackTrace)}");
                }
            }
        }

        private string ShortStack(string stack)
        {
            if (string.IsNullOrEmpty(stack)) return "(no stack)";
            var lines = stack.Split(new[] { '\n', '\r' }, StringSplitOptions.RemoveEmptyEntries);
            if (lines.Length == 0) return "(no stack)";
            return lines[0];
        }
    }

    /// <summary>
    /// NullInterceptor: optional helper that can be added to specific Manager classes to prevent NREs during placement calls.
    /// This is intentionally non-invasive and only demonstrates a pattern — real projects may want to implement domain-specific guards.
    /// </summary>
    public class NullInterceptor : MonoBehaviour
    {
        // Example: if a placement manager calls PlaceCard(card, pos) and card is null, instead of throwing we log and no-op.
        // This generic interceptor uses reflection: it finds public methods with known names and wraps them via dynamic replacement where possible.
        // Note: full method replacement/IL patching is out of scope. This is a conservative logger + quick guard pattern.

        public bool enabledGuard = true;
        public string[] methodNameKeywords = new string[] { "place", "deploy", "spawn", "addcard" };

        private void Start()
        {
            // For demonstration only: scan for MonoBehaviours that match name heuristics and print possible methods to guard.
            if (!enabledGuard) return;

            MonoBehaviour[] monos = FindObjectsOfType<MonoBehaviour>(true);
            foreach (var mb in monos)
            {
                if (mb == null) continue;
                string name = mb.GetType().Name.ToLowerInvariant();
                if (name.Contains("placement") || name.Contains("deploy") || name.Contains("placementmanager"))
                {
                    var methods = mb.GetType().GetMethods(BindingFlags.Public | BindingFlags.Instance);
                    foreach (var m in methods)
                    {
                        string mn = m.Name.ToLowerInvariant();
                        foreach (var kw in methodNameKeywords)
                        {
                            if (mn.Contains(kw))
                            {
                                Debug.Log($"[MegaFixes:NullInterceptor] Candidate guard method: {mb.GetType().Name}.{m.Name} (params={m.GetParameters().Length})");
                            }
                        }
                    }
                }
            }
        }
    }

    #endregion

    #region Extensive Comments Footer (helpful notes)

    // -----------------------------------------------------------------------------
    // IMPORTANT USAGE NOTES / TROUBLESHOOTING:
    //
    // - Backup: seriously back up your project before dropping this file in.
    // - Tuning: use the Inspector to tune multipliers. Setting placementAreaMultiplier <1 will shrink placement zones.
    // - Debugging: use MegaFixes.Instance to call ApplyMegaFixes() manually if you need to re-run after scene load.
    // - Heuristics: this file uses heuristics (name matching and reflection). If your code uses obfuscated names or different patterns
    //   you may need to edit the keyword arrays (placementNameKeywords, princessKeywords) to include matches from your project.
    // - Safety: this patch only changes numeric-like fields and attempts to mutate component instances safely. It avoids changing integer "counts"
    //   unless it appears to represent a numeric stat (e.g., damage or health). Still exercise care.
    //
    // EXTENSION IDEAS (future):
    // - Add a ScriptableObject config so designers can create named tuning profiles.
    // - Add a small EditorWindow to preview which components would be affected before committing changes.
    // - Replace heuristic in-place edits with a rewriter or data-driven approach for production.
    // -----------------------------------------------------------------------------

    #endregion
}
