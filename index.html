<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Clash Royale 3D Mega Fixed</title>
  <style>
    html,body{margin:0;padding:0;height:100%;overflow:hidden;background:#0b1220;font-family:sans-serif;color:#fff}
    canvas{display:block;position:absolute;top:0;left:0;z-index:0;}
    .ui{position:absolute;top:10px;left:10px;z-index:10;background:rgba(0,0,0,0.5);padding:10px;border-radius:8px}
    button{margin:2px;padding:6px 12px;border:none;border-radius:4px;background:#1e90ff;color:#fff;cursor:pointer}
    .healthbar{height:4px;background:red;}
  </style>
</head>
<body>
  <div class="ui">
    <button id="spawnTroop">Spawn Troop</button>
    <button id="spawnEnemy">Spawn Enemy</button>
    <button id="reset">Reset</button>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script>
    // ----------------- BASELINE ARENA SETUP -----------------
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB); // sky-blue always visible

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 50, 80);
    camera.lookAt(0,0,0);

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const ambient = new THREE.AmbientLight(0xffffff,0.6);
    scene.add(ambient);
    const dirLight = new THREE.DirectionalLight(0xffffff,0.8);
    dirLight.position.set(50,100,50);
    dirLight.castShadow = true;
    scene.add(dirLight);

    const groundGeo = new THREE.PlaneGeometry(100,100);
    const groundMat = new THREE.MeshPhongMaterial({color:0x228B22});
    const ground = new THREE.Mesh(groundGeo,groundMat);
    ground.rotation.x = -Math.PI/2;
    ground.receiveShadow = true;
    scene.add(ground);

    const riverGeo = new THREE.PlaneGeometry(100,20);
    const riverMat = new THREE.MeshPhongMaterial({color:0x1E90FF});
    const river = new THREE.Mesh(riverGeo,riverMat);
    river.rotation.x = -Math.PI/2;
    river.position.z = 0;
    scene.add(river);

    const bridgeGeo = new THREE.BoxGeometry(20,1,5);
    const bridgeMat = new THREE.MeshPhongMaterial({color:0x8B4513});
    const bridgeLeft = new THREE.Mesh(bridgeGeo,bridgeMat);
    bridgeLeft.position.set(-25,0.5,0);
    const bridgeRight = bridgeLeft.clone();
    bridgeRight.position.set(25,0.5,0);
    scene.add(bridgeLeft,bridgeRight);

    const towerGeo = new THREE.CylinderGeometry(3,3,12,32);
    const towerMat = new THREE.MeshPhongMaterial({color:0xaaaaaa});
    const towers = [];
    const towerPositions = [
      [-30,6,-30],[30,6,-30],[0,6,-40],
      [-30,6,30],[30,6,30],[0,6,40]
    ];
    towerPositions.forEach(pos=>{
      const t = new THREE.Mesh(towerGeo,towerMat);
      t.position.set(...pos);
      t.castShadow = true;
      t.receiveShadow = true;
      t.health = 200;
      scene.add(t);
      towers.push(t);
    });

    // ----------------- TROOPS -----------------
    class Troop{
      constructor(x,z,isEnemy=false){
        this.isEnemy = isEnemy;
        this.mesh = new THREE.Mesh(
          new THREE.SphereGeometry(2,16,16),
          new THREE.MeshPhongMaterial({color:isEnemy?0xff0000:0x0000ff})
        );
        this.mesh.position.set(x,2,z);
        this.mesh.castShadow = true;
        scene.add(this.mesh);
        this.hp = 50;
        this.speed = 0.2;
      }
      update(){
        if(this.hp<=0) return;
        // Move toward nearest enemy troop or tower
        let target = null;
        let minDist = Infinity;
        [...troops.filter(t=>t.isEnemy!==this.isEnemy && t.hp>0),...towers].forEach(e=>{
          const d = this.mesh.position.distanceTo(e.position);
          if(d<minDist){minDist=d;target=e;}
        });
        if(target){
          if(minDist<5){
            // Attack
            if(target.hp!==undefined){
              target.hp -= 0.1;
              if(target.hp<=0 && target.mesh){
                scene.remove(target.mesh);
              }
            } else {
              target.hp -= 0.1;
              if(target.hp<=0) scene.remove(target);
            }
          } else {
            // Move closer
            const dir = target.position.clone().sub(this.mesh.position).normalize();
            this.mesh.position.add(dir.multiplyScalar(this.speed));
          }
        }
      }
    }

    const troops = [];

    // ----------------- UI BUTTONS -----------------
    document.getElementById('spawnTroop').onclick = ()=>{
      troops.push(new Troop(0,40,false));
    };
    document.getElementById('spawnEnemy').onclick = ()=>{
      troops.push(new Troop(0,-40,true));
    };
    document.getElementById('reset').onclick = ()=>{
      troops.forEach(t=>scene.remove(t.mesh));
      troops.length=0;
      towers.forEach(t=>{t.hp=200;scene.add(t);});
    };

    // ----------------- LOOP -----------------
    function animate(){
      requestAnimationFrame(animate);
      troops.forEach(t=>t.update());
      renderer.render(scene,camera);
    }
    animate();

    // Resize fix
    window.addEventListener('resize',()=>{
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth,window.innerHeight);
    });
  </script>
</body>
</html>
