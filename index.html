<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>MegaFixes — Browser Edition (Playable)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1720;
      --panel:#0b1220;
      --accent:#00b4ff;
      --muted:#9aa4b2;
      --card:#ffe4b5;
    }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#081018);color:#e6eef6;font-family:Inter,Segoe UI,Roboto,Arial;}
    header{display:flex;align-items:center;justify-content:space-between;padding:12px 18px;border-bottom:1px solid rgba(255,255,255,0.03);}
    h1{font-size:16px;margin:0;}
    .container{display:flex;gap:12px;height:calc(100% - 56px);padding:12px;}
    .left{
      flex:1;
      display:flex;flex-direction:column;align-items:center;justify-content:flex-start;
    }
    #canvasWrap{background:linear-gradient(#17322a,#16322d);padding:8px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);}
    canvas{display:block;background:#2b5138;border-radius:6px;box-shadow:0 8px 20px rgba(0,0,0,0.5);}
    .right{width:380px; background:var(--panel); border-radius:8px;padding:12px;box-shadow:0 6px 18px rgba(0,0,0,0.5);overflow:auto;}
    .section{margin-bottom:12px;}
    label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px;}
    input[type="range"]{width:100%;}
    .row{display:flex;gap:8px;align-items:center;}
    .btn{display:inline-block;padding:8px 10px;border-radius:8px;background:#0b2b2a;border:1px solid rgba(255,255,255,0.03);cursor:pointer;color:#dff7ff;}
    .btn.secondary{background:#132230;}
    small{color:var(--muted);}
    .log{height:140px;overflow:auto;background:#071016;padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.03);font-family:monospace;font-size:12px;}
    .statRow{display:flex;justify-content:space-between;margin:6px 0;padding:6px;background:rgba(255,255,255,0.01);border-radius:6px;}
    footer{padding:10px 18px;color:var(--muted);font-size:12px;border-top:1px solid rgba(255,255,255,0.03);}
    .toggle{display:inline-flex;align-items:center;gap:8px;}
    .chip{background:#071a18;padding:6px 8px;border-radius:999px;font-size:12px;border:1px solid rgba(255,255,255,0.02);}
    .muted{color:var(--muted);}
    .divider{height:1px;background:rgba(255,255,255,0.02);margin:10px 0;}
  </style>
</head>
<body>
  <header>
    <h1>MegaFixes — Browser Edition (Playable prototype)</h1>
    <div class="chip">Drop-in replacement: C# → JS/HTML</div>
  </header>

  <div class="container">
    <div class="left">
      <div id="canvasWrap">
        <canvas id="gameCanvas" width="1000" height="600"></canvas>
      </div>
      <div style="margin-top:8px;display:flex;gap:8px;align-items:center;">
        <button id="btnPause" class="btn">Pause</button>
        <button id="btnStep" class="btn secondary">Step</button>
        <button id="btnReset" class="btn secondary">Reset</button>
        <div style="margin-left:12px;"><small class="muted">Click inside placement area to drop a unit. Press H to hide UI</small></div>
      </div>
    </div>

    <div class="right">
      <div class="section">
        <strong>MegaFixes Controls</strong>
        <div class="divider"></div>
        <div class="statRow"><div>Game state</div><div id="stateLabel">running</div></div>
        <div class="statRow"><div>Tower count</div><div id="towerCount">0</div></div>
        <div class="statRow"><div>Units on field</div><div id="unitCount">0</div></div>
      </div>

      <div class="section">
        <label>Placement Area Multiplier (<span id="placementMulLabel">1.5</span>)</label>
        <input id="placementMul" type="range" min="0.5" max="3" step="0.05" value="1.5" />
        <small class="muted">Scale the playable area where you can place cards.</small>
      </div>

      <div class="section">
        <label>Princess Tower — Damage Multiplier (<span id="dmgMulLabel">0.75</span>)</label>
        <input id="dmgMul" type="range" min="0.1" max="2.0" step="0.01" value="0.75" />
        <label>Range Multiplier (<span id="rangeMulLabel">0.9</span>)</label>
        <input id="rangeMul" type="range" min="0.1" max="2.0" step="0.01" value="0.9" />
        <label>Fire Rate Multiplier (<span id="rateMulLabel">0.95</span>)</label>
        <input id="rateMul" type="range" min="0.1" max="3.0" step="0.01" value="0.95" />
        <label>Health Multiplier (<span id="hpMulLabel">0.95</span>)</label>
        <input id="hpMul" type="range" min="0.1" max="2.0" step="0.01" value="0.95" />
      </div>

      <div class="section">
        <label>Bug-fix / Guards</label>
        <div class="row" style="margin-bottom:8px;">
          <label style="flex:1"><input type="checkbox" id="chkClampRot" checked /> Clamp card preview rotation</label>
        </div>
        <div class="row" style="margin-bottom:8px;">
          <label style="flex:1"><input type="checkbox" id="chkPreventNull" checked /> Prevent null placements</label>
        </div>
        <label>Clamp tilt max (deg)</label>
        <input id="clampTilt" type="range" min="0" max="45" step="1" value="15" />
      </div>

      <div class="section">
        <strong>Quick actions</strong>
        <div style="display:flex;gap:8px;margin-top:8px;">
          <button id="downloadGame" class="btn">Download State</button>
          <button id="downloadLog" class="btn secondary">Download Log</button>
        </div>
      </div>

      <div class="section">
        <label>Debug / Console</label>
        <div class="log" id="logBox"></div>
      </div>

      <div class="section">
        <small class="muted">Save this file as <code>megafixes.html</code> and publish with GitHub Pages to run from the web. This prototype implements core features from the original C# mega file adapted to JavaScript + Canvas.</small>
      </div>
    </div>
  </div>

  <footer>
    <small class="muted">Tip: commit this file to your repo root and enable GitHub Pages (main branch). To revert, replace with previous build. Built as a browser-targeted port of your MegaFixes C# patch.</small>
  </footer>

  <script>
  /*********************************************************************
   * MegaFixes Browser Edition — Playable Prototype
   * - Simulated mini Clash Royale environment in canvas
   * - Implements placement area expansion, princess tower nerfs, and runtime guards
   * - Single-file: no dependencies
   *
   * Controls:
   * - Click inside placement area to place a unit (ally)
   * - Pause / Step / Reset buttons on the left
   * - Tweak multipliers in the right panel and they'll apply live
   *
   * Note: This is a playable prototype and intentionally self-contained.
   *********************************************************************/

  (function(){
    // ======= Utility & logging (small runtime guard) =======
    function safeLog(...args){
      try {
        const t = args.join(' ');
        const lb = document.getElementById('logBox');
        if(lb){
          const now = new Date().toLocaleTimeString();
          lb.innerText = now + '  ' + t + '\n' + lb.innerText;
          // keep it short
          if(lb.innerText.length > 20000) lb.innerText = lb.innerText.substr(0,20000);
        } else {
          console.log(...args);
        }
      } catch(e){}
    }

    // clamp utility
    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

    // distance
    function dist(a,b){
      const dx = a.x - b.x, dy = a.y - b.y;
      return Math.sqrt(dx*dx + dy*dy);
    }

    // ======= Core Game Data and Config (mirrors inspector-exposed fields) =======
    const Config = {
      placementAreaMultiplier: parseFloat(document.getElementById('placementMul').value || 1.5),

      princessDamageMultiplier: parseFloat(document.getElementById('dmgMul').value || 0.75),
      princessRangeMultiplier: parseFloat(document.getElementById('rangeMul').value || 0.9),
      princessFireRateMultiplier: parseFloat(document.getElementById('rateMul').value || 0.95),
      princessHealthMultiplier: parseFloat(document.getElementById('hpMul').value || 0.95),

      clampCardRotation: document.getElementById('chkClampRot').checked,
      preventNullPlacements: document.getElementById('chkPreventNull').checked,
      clampMaxTiltDegrees: parseFloat(document.getElementById('clampTilt').value || 15),

      // gameplay tuning (local defaults)
      unitBaseHP: 200,
      unitBaseDamage: 40,
      unitSpeed: 60, // px per second
      unitSize: 18
    };

    // update UI labels when sliders change
    function syncUIToConfig(){
      document.getElementById('placementMulLabel').innerText = Config.placementAreaMultiplier.toFixed(2);
      document.getElementById('dmgMulLabel').innerText = Config.princessDamageMultiplier.toFixed(2);
      document.getElementById('rangeMulLabel').innerText = Config.princessRangeMultiplier.toFixed(2);
      document.getElementById('rateMulLabel').innerText = Config.princessFireRateMultiplier.toFixed(2);
      document.getElementById('hpMulLabel').innerText = Config.princessHealthMultiplier.toFixed(2);

      document.getElementById('stateLabel').innerText = Game.paused ? 'paused' : 'running';
      document.getElementById('towerCount').innerText = Game.towers.length;
      document.getElementById('unitCount').innerText = Game.units.length;
    }

    // attach listeners to UI
    document.getElementById('placementMul').addEventListener('input',e=>{
      Config.placementAreaMultiplier = parseFloat(e.target.value);
      syncUIToConfig();
      Game.recomputePlacementZone();
      safeLog('[MegaFixes] placementAreaMultiplier ->', Config.placementAreaMultiplier);
    });
    document.getElementById('dmgMul').addEventListener('input',e=>{
      Config.princessDamageMultiplier = parseFloat(e.target.value);
      syncUIToConfig();
      Game.applyPrincessNerfs();
      safeLog('[MegaFixes] princessDamageMultiplier ->', Config.princessDamageMultiplier);
    });
    document.getElementById('rangeMul').addEventListener('input',e=>{
      Config.princessRangeMultiplier = parseFloat(e.target.value);
      syncUIToConfig();
      Game.applyPrincessNerfs();
      safeLog('[MegaFixes] princessRangeMultiplier ->', Config.princessRangeMultiplier);
    });
    document.getElementById('rateMul').addEventListener('input',e=>{
      Config.princessFireRateMultiplier = parseFloat(e.target.value);
      syncUIToConfig();
      Game.applyPrincessNerfs();
      safeLog('[MegaFixes] princessFireRateMultiplier ->', Config.princessFireRateMultiplier);
    });
    document.getElementById('hpMul').addEventListener('input',e=>{
      Config.princessHealthMultiplier = parseFloat(e.target.value);
      syncUIToConfig();
      Game.applyPrincessNerfs();
      safeLog('[MegaFixes] princessHealthMultiplier ->', Config.princessHealthMultiplier);
    });

    document.getElementById('chkClampRot').addEventListener('change',e=>{
      Config.clampCardRotation = e.target.checked;
      safeLog('[MegaFixes] clampCardRotation ->', Config.clampCardRotation);
    });
    document.getElementById('chkPreventNull').addEventListener('change',e=>{
      Config.preventNullPlacements = e.target.checked;
      safeLog('[MegaFixes] preventNullPlacements ->', Config.preventNullPlacements);
    });
    document.getElementById('clampTilt').addEventListener('input',e=>{
      Config.clampMaxTiltDegrees = parseFloat(e.target.value);
      safeLog('[MegaFixes] clampMaxTiltDegrees ->', Config.clampMaxTiltDegrees);
    });

    // quick actions
    document.getElementById('btnPause').addEventListener('click', ()=>{
      Game.togglePause();
    });
    document.getElementById('btnStep').addEventListener('click', ()=>{
      Game.stepOneFrame();
    });
    document.getElementById('btnReset').addEventListener('click', ()=>{
      Game.reset();
    });

    document.getElementById('downloadGame').addEventListener('click', ()=>{
      const s = JSON.stringify(Game.serializeState(), null, 2);
      const blob = new Blob([s], {type:'application/json'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'megafixes_game_state.json';
      a.click();
      URL.revokeObjectURL(a.href);
    });

    document.getElementById('downloadLog').addEventListener('click', ()=>{
      const content = document.getElementById('logBox').innerText || '';
      const blob = new Blob([content], {type:'text/plain'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'megafixes_console.log';
      a.click();
      URL.revokeObjectURL(a.href);
    });

    // ======= Canvas and rendering setup =======
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const CW = canvas.width, CH = canvas.height;

    // Game object encapsulating entities, towers, units
    const Game = {
      towers: [],
      units: [],
      projectiles: [],
      lastTimestamp: null,
      paused: false,
      accumulator: 0,
      stepRequested: false,

      // placement zone represented as rectangle
      placementZone: { x: (CW - 400) / 2, y: (CH - 200) / 2, w: 400, h: 200 },

      // initialization
      init: function(){
        this.reset();
        // attach canvas pointer for placement
        canvas.addEventListener('pointerdown', e=>{
          const rect = canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          this.onCanvasClick({x,y});
        });

        // keyboard shortcuts
        window.addEventListener('keydown', e=>{
          if(e.key === 'h' || e.key === 'H'){
            const right = document.querySelector('.right');
            right.style.display = (right.style.display === 'none') ? 'block' : 'none';
          }
        });
      },

      reset: function(){
        // clear arrays
        this.towers = [];
        this.units = [];
        this.projectiles = [];
        this.paused = false;
        this.accumulator = 0;
        this.stepRequested = false;
        this.lastTimestamp = null;

        // establish placement zone according to multiplier
        this.recomputePlacementZone();

        // spawn towers — typical Clash: left and right princess towers and central King (we'll spawn two princess towers to match C# heuristics)
        this.spawnPrincessTowers();

        safeLog('[MegaFixes] Game reset.');
        syncUIToConfig();
      },

      recomputePlacementZone: function(){
        const baseW = 400, baseH = 200;
        const m = Config.placementAreaMultiplier;
        const w = baseW * m, h = baseH * m;
        const x = Math.round((CW - w) / 2);
        const y = Math.round((CH - h) / 2);
        this.placementZone = {x,y,w,h};
      },

      spawnPrincessTowers: function(){
        this.towers = [];
        // left tower
        const left = {
          id: 'princess-left',
          x: 80,
          y: 120,
          baseHP: 1000,
          baseDamage: 50,
          baseRange: 180,
          baseFireRate: 1.0, // shots per second
          hp: 1000,
          damage: 50,
          range: 180,
          fireRate: 1.0,
          cooldown: 0
        };
        const right = {
          id: 'princess-right',
          x: CW - 80,
          y: 120,
          baseHP: 1000,
          baseDamage: 50,
          baseRange: 180,
          baseFireRate: 1.0,
          hp: 1000,
          damage: 50,
          range: 180,
          fireRate: 1.0,
          cooldown: 0
        };
        this.towers.push(left, right);
        // apply nerfs
        this.applyPrincessNerfs();
      },

      applyPrincessNerfs: function(){
        // Mirror the C# multipliers
        this.towers.forEach(t=>{
          t.hp = Math.max(0, Math.round(t.baseHP * Config.princessHealthMultiplier));
          t.damage = Math.max(0, Math.round(t.baseDamage * Config.princessDamageMultiplier));
          t.range = Math.max(1, Math.round(t.baseRange * Config.princessRangeMultiplier));
          t.fireRate = Math.max(0.05, t.baseFireRate * Config.princessFireRateMultiplier);
          // reset cooldowns to avoid immediate-fire weirdness
          t.cooldown = 0;
        });
        safeLog('[MegaFixes] Applied princess nerfs:', 'hp×'+Config.princessHealthMultiplier, 'dmg×'+Config.princessDamageMultiplier, 'range×'+Config.princessRangeMultiplier, 'rate×'+Config.princessFireRateMultiplier);
        syncUIToConfig();
      },

      // called when user clicks canvas
      onCanvasClick: function(pos){
        // null-guard for placement
        if(Config.preventNullPlacements === true){
          if(!pos || typeof pos.x !== 'number' || typeof pos.y !== 'number'){
            safeLog('[MegaFixes] null placement prevented (invalid click position).');
            return;
          }
        }
        // ensure inside placement zone
        const p = this.placementZone;
        if(pos.x < p.x || pos.x > p.x + p.w || pos.y < p.y || pos.y > p.y + p.h){
          safeLog('[MegaFixes] Click outside placement zone — ignoring.');
          return;
        }
        // spawn a unit with gentle preview rotation logic
        const unit = this.spawnUnit(pos);
        safeLog('[MegaFixes] Spawned unit id=' + unit.id + ' at ' + Math.round(pos.x) + ',' + Math.round(pos.y));
        syncUIToConfig();
      },

      spawnUnit: function(pos){
        const id = 'u' + (Math.random()*1e9|0).toString(36);
        // random direction for demo to avoid stacking exactly
        const unit = {
          id,
          x: pos.x,
          y: pos.y,
          vx: 0,
          vy: 0,
          angle: (Math.random()*360),
          hp: Config.unitBaseHP,
          dmg: Config.unitBaseDamage,
          speed: Config.unitSpeed,
          size: Config.unitSize,
          target: null,
          team: 'ally'
        };

        // clamp rotation preview if configured (simulate placement preview clamp)
        if(Config.clampCardRotation){
          const a = unit.angle;
          const max = Config.clampMaxTiltDegrees;
          // normalize -180..180
          const norm = (a > 180) ? a - 360 : a;
          const clamped = clamp(norm, -max, max);
          unit.angle = (clamped < 0) ? (360 + clamped) : clamped;
        }

        // On spawn, pick nearest enemy tower as target
        unit.target = this.findNearestEnemyTower(unit);
        this.units.push(unit);
        return unit;
      },

      findNearestEnemyTower: function(unit){
        if(this.towers.length === 0) return null;
        let best = null, bestDist = Number.POSITIVE_INFINITY;
        for(const t of this.towers){
          if(t.hp <= 0) continue;
          const d = dist({x:unit.x,y:unit.y}, t);
          if(d < bestDist){ bestDist = d; best = t; }
        }
        return best;
      },

      // spawn projectile
      spawnProjectile: function(origin, target, power){
        const proj = {
          id: 'p' + (Math.random()*1e9|0).toString(36),
          x: origin.x,
          y: origin.y,
          tx: target.x,
          ty: target.y,
          targetRef: target,
          speed: 280,
          power: power,
          dead: false
        };
        this.projectiles.push(proj);
        return proj;
      },

      // simulation step (dt seconds)
      step: function(dt){
        // towers act: reduce cooldowns and fire when ready
        for(const t of this.towers){
          if(t.hp <= 0) continue;
          t.cooldown -= dt;
          if(t.cooldown <= 0){
            // find nearest unit in range
            let best = null, bestD = Number.POSITIVE_INFINITY;
            for(const u of this.units){
              if(u.hp <= 0) continue;
              const d = dist({x:t.x,y:t.y}, u);
              if(d <= t.range && d < bestD){
                bestD = d; best = u;
              }
            }
            if(best){
              // fire
              this.spawnProjectile({x:t.x,y:t.y}, best, t.damage);
              t.cooldown = 1.0 / t.fireRate;
              // small debug log
              //safeLog('[MegaFixes] Tower',t.id,'fired at',best.id);
            }
          }
        }

        // projectiles travel
        for(const p of this.projectiles){
          if(p.dead) continue;
          const tr = p.targetRef;
          // if target died, mark dead
          if(!tr || tr.hp <= 0){ p.dead = true; continue; }
          const dx = p.tx - p.x, dy = p.ty - p.y;
          const d = Math.sqrt(dx*dx + dy*dy);
          if(d < 6){
            // hit
            tr.hp -= p.power;
            // clamp
            if(tr.hp < 0) tr.hp = 0;
            p.dead = true;
            safeLog('[MegaFixes] Projectile hit', tr.id, 'for', p.power, '-> hp=' + tr.hp);
            continue;
          }
          // move toward target
          const nx = dx/d, ny = dy/d;
          const move = p.speed * dt;
          p.x += nx * Math.min(move, d);
          p.y += ny * Math.min(move, d);
        }
        // cleanup dead projectiles
        this.projectiles = this.projectiles.filter(p => !p.dead);

        // units move toward their target
        for(const u of this.units){
          if(u.hp <= 0) continue;
          if(!u.target || u.target.hp <= 0){
            u.target = this.findNearestEnemyTower(u);
          }
          if(u.target){
            // move toward target
            const dx = u.target.x - u.x, dy = u.target.y - u.y;
            const d = Math.sqrt(dx*dx + dy*dy);
            if(d > 6){
              const nx = dx / d, ny = dy / d;
              const move = u.speed * dt;
              u.x += nx * Math.min(move, d);
              u.y += ny * Math.min(move, d);
            } else {
              // in melee range — attack tower (we'll apply damage directly per second)
              u.target.hp -= u.dmg * dt;
              if(u.target.hp < 0) u.target.hp = 0;
            }
          }
        }

        // remove dead units
        this.units = this.units.filter(u => u.hp > 0);

        // check towers death (and maybe respawn after a while if you want)
        // For now just keep them dead when hp==0
      },

      // serialize for download
      serializeState: function(){
        return {
          towers: this.towers.map(t=>({id:t.id,x:t.x,y:t.y,hp:t.hp,damage:t.damage,range:t.range,fireRate:t.fireRate})),
          units: this.units.map(u=>({id:u.id,x:u.x,y:u.y,hp:u.hp})),
          conf: Config
        };
      },

      // per-frame tick called by requestAnimationFrame
      tick: function(timestamp){
        if(this.lastTimestamp === null) this.lastTimestamp = timestamp;
        const dt = Math.min(0.05, (timestamp - this.lastTimestamp) / 1000); // clamp dt
        this.lastTimestamp = timestamp;

        if(!this.paused || this.stepRequested){
          // step simulation with dt
          this.step(dt);
          this.stepRequested = false;
        }

        // rendering
        Renderer.render();

        // schedule next frame
        if(!this.paused) requestAnimationFrame(this.tick.bind(this));
      },

      togglePause: function(){
        this.paused = !this.paused;
        document.getElementById('btnPause').innerText = this.paused ? 'Resume' : 'Pause';
        if(!this.paused){
          // resume loop
          this.lastTimestamp = null;
          requestAnimationFrame(this.tick.bind(this));
        }
        syncUIToConfig();
      },

      stepOneFrame: function(){
        this.stepRequested = true;
        if(this.paused){
          // show one frame
          this.lastTimestamp = performance.now();
          this.tick(performance.now());
        }
      }
    };

    // ======= Rendering (Canvas-based) =======
    const Renderer = {
      render: function(){
        // clear
        ctx.clearRect(0,0,CW,CH);

        // draw background grid
        this.drawBackground();

        // draw placement zone
        this.drawPlacementZone();

        // draw units
        for(const u of Game.units){
          this.drawUnit(u);
        }

        // draw towers
        for(const t of Game.towers){
          this.drawTower(t);
        }

        // draw projectiles on top
        for(const p of Game.projectiles){
          this.drawProjectile(p);
        }

      },

      drawBackground: function(){
        // subtle grid
        ctx.save();
        ctx.fillStyle = '#112e20';
        ctx.fillRect(0,0,CW,CH);
        ctx.strokeStyle = 'rgba(255,255,255,0.02)';
        ctx.lineWidth = 1;
        for(let x=0;x<CW;x+=40){
          ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,CH); ctx.stroke();
        }
        for(let y=0;y<CH;y+=40){
          ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(CW,y); ctx.stroke();
        }
        ctx.restore();
      },

      drawPlacementZone: function(){
        const p = Game.placementZone;
        ctx.save();
        ctx.fillStyle = 'rgba(10,60,120,0.08)';
        ctx.fillRect(p.x, p.y, p.w, p.h);
        ctx.strokeStyle = 'rgba(20,130,255,0.5)';
        ctx.setLineDash([6,6]);
        ctx.lineWidth = 2;
        ctx.strokeRect(p.x, p.y, p.w, p.h);

        // explanatory text
        ctx.fillStyle = '#cfefff';
        ctx.font = '12px Inter, Arial';
        ctx.fillText('Placement Zone', p.x + 8, p.y + 16);
        ctx.restore();
      },

      drawUnit: function(u){
        ctx.save();
        // body
        ctx.translate(u.x, u.y);
        ctx.rotate(u.angle * Math.PI / 180);
        // draw circle as unit
        ctx.fillStyle = '#ffdfb3';
        ctx.beginPath();
        ctx.arc(0,0,u.size/2,0,Math.PI*2);
        ctx.fill();
        // health ring
        ctx.strokeStyle = '#222';
        ctx.lineWidth = 2;
        ctx.stroke();

        // health bar
        ctx.rotate(-u.angle * Math.PI / 180);
        ctx.fillStyle = '#772222';
        const w = u.size;
        const hpPerc = clamp(u.hp / Config.unitBaseHP, 0, 1);
        ctx.fillRect(-w/2, -u.size - 8, w * hpPerc, 4);
        ctx.strokeStyle = '#000';
        ctx.strokeRect(-w/2, -u.size - 8, w, 4);
        ctx.restore();
      },

      drawTower: function(t){
        ctx.save();
        // tower base
        ctx.fillStyle = t.hp > 0 ? '#3b5f3d' : '#3b3b3b';
        ctx.fillRect(t.x - 30, t.y - 40, 60, 80);
        // roof
        ctx.fillStyle = '#225522';
        ctx.beginPath();
        ctx.moveTo(t.x - 34, t.y - 40);
        ctx.lineTo(t.x, t.y - 70);
        ctx.lineTo(t.x + 34, t.y - 40);
        ctx.closePath();
        ctx.fill();

        // range circle (subtle)
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(200,200,255,0.06)';
        ctx.lineWidth = 1;
        ctx.arc(t.x, t.y, t.range, 0, Math.PI*2);
        ctx.stroke();

        // hp text
        ctx.fillStyle = '#e7f6ff';
        ctx.font = '12px Inter, Arial';
        const label = t.id + ' HP:' + Math.round(t.hp);
        ctx.fillText(label, t.x - ctx.measureText(label).width/2, t.y + 50);
        ctx.restore();
      },

      drawProjectile: function(p){
        ctx.save();
        ctx.fillStyle = '#ffd3d3';
        ctx.beginPath();
        ctx.arc(p.x, p.y, 4, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
    };

    // ======= Start the game =======
    Game.init();
    // initial render
    Renderer.render();
    // start loop
    requestAnimationFrame(Game.tick.bind(Game));

    // expose Game to window for debugging
    window.MegaFixesGame = Game;

    // sync UI
    syncUIToConfig();
    safeLog('[MegaFixes] Prototype initialized — ported from C# MegaFixes into JS/HTML.');

    // small periodic UI update
    setInterval(syncUIToConfig, 250);

  })();
  </script>
</body>
</html>
