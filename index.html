<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Clash Royale — MEGA 3D (Bridges · Pathing · Combat)</title>
<link rel="preload" href="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js" as="script">
<style>
  /* --- UI Layout --- */
  html,body{height:100%;margin:0;background:#071019;color:#e6eef6;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial}
  #canvasHolder{position:absolute;left:0;top:0;right:420px;bottom:0;overflow:hidden}
  #ui{position:absolute;right:12px;top:12px;width:392px;background:linear-gradient(180deg,rgba(6,12,16,0.96),rgba(3,6,8,0.9));padding:14px;border-radius:10px;box-shadow:0 20px 40px rgba(0,0,0,0.6);z-index:20}
  .btn{padding:8px 10px;border-radius:8px;background:#0b2b2a;border:1px solid rgba(255,255,255,0.03);color:#dff7ff;cursor:pointer;margin-right:8px}
  .muted{color:#9fb3bf;font-size:12px}
  .deck{display:flex;gap:8px;margin-top:10px;flex-wrap:wrap}
  .card{width:82px;height:106px;background:#e8eedc;color:#082;display:flex;flex-direction:column;align-items:center;justify-content:center;border-radius:6px;cursor:pointer}
  .card.disabled{opacity:0.45;pointer-events:none}
  #elixirBar{height:18px;background:#042;border-radius:9px;margin-top:8px;overflow:hidden}
  #elixirFill{height:100%;width:0%;background:linear-gradient(180deg,#ffe26b,#ffc83a)}
  #log{margin-top:10px;height:180px;overflow:auto;background:#021016;padding:8px;border-radius:6px;font-family:monospace;font-size:12px}
  .small{font-size:12px;color:#9fb3bf}
  footer{position:absolute;right:12px;bottom:12px;color:#789}
  label.switch{display:inline-flex;align-items:center;gap:8px;cursor:pointer}
  input[type=checkbox]{width:16px;height:16px}
  /* responsive */
  @media (max-width:1200px){ #canvasHolder{right:320px} #ui{width:300px} .card{width:70px;height:86px} }
</style>
</head>
<body>
  <div id="canvasHolder"></div>
  <div id="ui">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <strong>CLASH — MEGA 3D</strong>
      <div class="muted">Bridges aligned · Full combat</div>
    </div>

    <div style="margin-top:10px;display:flex;align-items:center">
      <button id="btnPause" class="btn">Pause</button>
      <button id="btnStep" class="btn">Step</button>
      <button id="btnReset" class="btn">Reset</button>
      <label class="switch" style="margin-left:auto"><input id="debugToggle" type="checkbox"><span class="small muted">Debug</span></label>
    </div>

    <label class="muted" style="margin-top:10px">Deck / Elixir</label>
    <div id="elixirBar"><div id="elixirFill"></div></div>
    <div class="muted" id="elixirText">Elixir: 0 / 10</div>

    <div class="deck" id="deck"></div>
    <div class="muted" style="margin-top:8px">Click a card, then click anywhere on your side to deploy.</div>

    <div id="log"></div>
  </div>

  <footer>Drop into GitHub as <code>index.html</code></footer>

  <!-- THREE -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>

  <script>
  /**************************************************************************
   *  Mega 3D Clash — Single-file
   *  - Full Three.js visuals (shadows, fog, orbit)
   *  - Bridge-aligned waypoints (post-bridge sits on bridge entrance)
   *  - Troop pathing through waypoints
   *  - Troop vs troop melee, Troop -> tower attacks
   *  - Towers target only valid enemies (crossedBridge OR touching)
   *  - Towers shoot projectiles; projectiles damage targets on hit
   *  - Debug markers hidden by default; toggleable via UI
   *
   *  Author: assistant (merged & expanded per request)
   **************************************************************************/

  // -------------------- Utilities --------------------
  const logEl = document.getElementById('log');
  function log(...args){
    const s = new Date().toLocaleTimeString() + '  ' + args.map(a=> typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' ');
    logEl.innerText = s + '\\n' + logEl.innerText;
    // limit buffer
    if(logEl.innerText.length > 30000) logEl.innerText = logEl.innerText.substr(0,30000);
    console.log(...args);
  }
  function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
  function vdist(a,b){ const dx = a.x - b.x; const dz = a.z - b.z; return Math.sqrt(dx*dx + dz*dz); }
  function randRange(a,b){ return a + Math.random() * (b-a); }
  function now(){ return performance.now() / 1000; }

  // -------------------- Renderer / Camera / Controls --------------------
  const holder = document.getElementById('canvasHolder');
  const WIDTH = Math.max(1100, window.innerWidth - 420);
  const HEIGHT = window.innerHeight;
  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x071019, 0.0022);

  const camera = new THREE.PerspectiveCamera(50, WIDTH/HEIGHT, 0.1, 2000);
  camera.position.set(0, 180, 360);
  camera.lookAt(0, 12, 0);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(WIDTH, HEIGHT);
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  holder.appendChild(renderer.domElement);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.target.set(0, 12, 0);
  controls.enablePan = false;
  controls.enableDamping = true;
  controls.minDistance = 120;
  controls.maxDistance = 520;
  controls.update();

  // Resize handling
  window.addEventListener('resize', () => {
    const w = Math.max(900, window.innerWidth - 440);
    const h = window.innerHeight;
    renderer.setSize(w, h);
    camera.aspect = w/h; camera.updateProjectionMatrix();
  });

  // -------------------- Lights --------------------
  const hemi = new THREE.HemisphereLight(0xbbdffb, 0x080820, 0.55);
  scene.add(hemi);
  const sun = new THREE.DirectionalLight(0xffffff, 0.9);
  sun.position.set(120, 260, 90);
  sun.castShadow = true;
  sun.shadow.mapSize.set(2048, 2048);
  sun.shadow.camera.near = 10;
  sun.shadow.camera.far = 900;
  sun.shadow.camera.left = -400;
  sun.shadow.camera.right = 400;
  sun.shadow.camera.top = 400;
  sun.shadow.camera.bottom = -400;
  scene.add(sun);

  // -------------------- Arena Geometry --------------------
  const ARENA_W = 300, ARENA_H = 420, RIVER_H = 54, BRIDGE_W = 60;
  const arenaGroup = new THREE.Group(); scene.add(arenaGroup);

  // ground
  const groundMat = new THREE.MeshStandardMaterial({ color: 0x123b27, roughness: 0.9 });
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(ARENA_W, ARENA_H), groundMat);
  ground.rotation.x = -Math.PI/2;
  ground.receiveShadow = true;
  arenaGroup.add(ground);

  // river
  const riverMat = new THREE.MeshStandardMaterial({ color: 0x1e6b88, metalness: 0.07, roughness: 0.6 });
  const river = new THREE.Mesh(new THREE.PlaneGeometry(ARENA_W, RIVER_H), riverMat);
  river.rotation.x = -Math.PI/2; river.position.y = 0.02;
  river.receiveShadow = true; arenaGroup.add(river);

  // bridges
  const bridgeGeom = new THREE.BoxGeometry(BRIDGE_W, 2, 120);
  const bridgeMat = new THREE.MeshStandardMaterial({ color: 0x7d5a34 });
  const bridgeL = new THREE.Mesh(bridgeGeom, bridgeMat); bridgeL.position.set(-64, 0.5, 0); bridgeL.receiveShadow=true; bridgeL.castShadow=true; arenaGroup.add(bridgeL);
  const bridgeR = new THREE.Mesh(bridgeGeom, bridgeMat); bridgeR.position.set(64, 0.5, 0); bridgeR.receiveShadow=true; bridgeR.castShadow=true; arenaGroup.add(bridgeR);

  // arena edge decorative walls (for depth)
  const wallMat = new THREE.MeshStandardMaterial({ color: 0x0a2520 });
  const perimeter = new THREE.Mesh(new THREE.BoxGeometry(ARENA_W+24, 8, 20), wallMat); perimeter.position.set(0, 4, ARENA_H/2 + 10); perimeter.receiveShadow=true; scene.add(perimeter);
  const perimeter2 = perimeter.clone(); perimeter2.position.set(0, 4, -ARENA_H/2 - 10); scene.add(perimeter2);

  // -------------------- Waypoints (bridge-aligned: pre/post) --------------------
  // structure: [spawnAnchor, preBridge, postBridge(on bridge entrance), enemyApproach, enemySpawn]
  const Lanes = {
    left: [
      new THREE.Vector3(-64, 0, ARENA_H/2 - 46),
      new THREE.Vector3(-64, 0, 52),          // pre-bridge
      new THREE.Vector3(-64, 0, 0),           // post-bridge == bridge entrance (aligned to bridge)
      new THREE.Vector3(-64, 0, -52),
      new THREE.Vector3(-64, 0, -ARENA_H/2 + 46)
    ],
    right: [
      new THREE.Vector3(64, 0, ARENA_H/2 - 46),
      new THREE.Vector3(64, 0, 52),
      new THREE.Vector3(64, 0, 0),
      new THREE.Vector3(64, 0, -52),
      new THREE.Vector3(64, 0, -ARENA_H/2 + 46)
    ]
  };

  // Debug markers container (hidden by default)
  const debugMarkers = new THREE.Group();
  debugMarkers.visible = false;
  scene.add(debugMarkers);

  // draw debug markers if enabled
  function rebuildDebugMarkers(){
    debugMarkers.clear();
    const preMat = new THREE.MeshBasicMaterial({ color: 0x2ea0ff });
    const postMat = new THREE.MeshBasicMaterial({ color: 0xff4c4c });
    const preG = new THREE.SphereGeometry(3, 12, 12);
    const postG = new THREE.SphereGeometry(3.4, 12, 12);
    for(const side of ['left','right']){
      const lane = Lanes[side];
      const pre = new THREE.Mesh(preG, preMat); pre.position.copy(lane[1]); pre.position.y = 4; debugMarkers.add(pre);
      const post = new THREE.Mesh(postG, postMat); post.position.copy(lane[2]); post.position.y = 4; debugMarkers.add(post);
      // also show full path spheres
      for(let i=0;i<lane.length;i++){
        const g = new THREE.Mesh(new THREE.SphereGeometry(1.6,8,8), new THREE.MeshBasicMaterial({color:0xffffff,transparent:true,opacity:0.06}));
        g.position.copy(lane[i]); g.position.y = 1.8; debugMarkers.add(g);
      }
    }
  }
  rebuildDebugMarkers();

  // -------------------- World Pools --------------------
  const World = { troops: [], towers: [], projectiles: [], effects: [] };

  // -------------------- Visual Helpers --------------------
  function createHealthBar(width=26){
    const group = new THREE.Group();
    const back = new THREE.Mesh(new THREE.PlaneGeometry(width, 3), new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.6 }));
    const front = new THREE.Mesh(new THREE.PlaneGeometry(width-2, 2.2), new THREE.MeshBasicMaterial({ color: 0x33ff88 }));
    front.name = 'hpFront';
    front.position.z = 0.01;
    back.add(front);
    group.add(back);
    group.position.y = 36;
    return group;
  }

  function towerMesh(kind, team){
    const col = (team==='player') ? 0x2f7a47 : 0x7a2f2f;
    const geo = new THREE.CylinderGeometry(14, 14, 34, 14);
    const mat = new THREE.MeshStandardMaterial({ color: col, metalness: 0.05, roughness: 0.6 });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.castShadow = true; mesh.receiveShadow = true;
    return mesh;
  }

  function troopMesh(team, size){
    const col = (team==='player') ? 0xffe0b0 : 0xffb0b0;
    const geo = new THREE.BoxGeometry(size, size, size);
    const mat = new THREE.MeshStandardMaterial({ color: col, roughness: 0.6 });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.castShadow = true; mesh.receiveShadow = true;
    return mesh;
  }

  // -------------------- Tower Class --------------------
  function Tower(opts){
    this.team = opts.team;
    this.kind = opts.kind; // 'princess' or 'king'
    this.pos = opts.pos.clone();
    this.baseHP = (this.kind === 'king') ? 1900 : 1100;
    this.hp = this.baseHP;
    this.baseDamage = (this.kind === 'king') ? 110 : 55;
    this.baseRange = (this.kind === 'king') ? 150 : 120;
    this.baseFireRate = 1.0; // attacks per second
    this.damage = this.baseDamage;
    this.range = this.baseRange;
    this.fireRate = this.baseFireRate;
    this.cooldown = 0;
    this.mesh = towerMesh(this.kind, this.team);
    this.mesh.position.set(this.pos.x, 18, this.pos.z);
    this.hpBar = createHealthBar(28);
    this.hpBar.position.set(this.pos.x, 46, this.pos.z);
    scene.add(this.mesh);
    scene.add(this.hpBar);
    this.id = this.team + '-' + this.kind;
  }

  Tower.prototype.updateVisual = function(){
    const front = this.hpBar.children[0].getObjectByName('hpFront');
    if(front){
      const pct = clamp(this.hp / this.baseHP, 0, 1);
      front.scale.x = pct;
      front.position.x = -( (28-2) * (1 - pct) ) / 2;
    }
    if(this.hp <= 0){
      // visually deactivated
      if(this.mesh.material) this.mesh.material.color.setHex(0x333333);
    }
  };

  // Tower targeting: only target troops that are appropriate:
  // - same side of arena (z sign), and either troop.crossedBridge OR touching tower
  Tower.prototype.canTarget = function(candidate){
    if(!candidate || candidate.hp <= 0) return false;
    if(Math.sign(this.pos.z) !== Math.sign(candidate.mesh.position.z)) return false;
    const d = vdist(this.pos, candidate.mesh.position);
    const touchThreshold = (candidate.size || 8) + 14;
    if(!candidate.crossedBridge && d > this.range && d > touchThreshold) return false;
    return d <= this.range || d <= touchThreshold;
  };

  Tower.prototype.tryFire = function(dt){
    if(this.hp <= 0) return;
    if(this.cooldown > 0){ this.cooldown -= dt; return; }
    // king wake rule: simplified - if any princess alive, king sleeps
    if(this.kind === 'king'){
      const teamPrincesses = World.towers.filter(t => t.team === this.team && t.kind === 'princess');
      const anyAlive = teamPrincesses.some(p => p.hp > 0);
      if(anyAlive) return;
    }
    // find nearest valid troop
    let best = null, bd = Infinity;
    for(const u of World.troops){
      if(u.team === this.team) continue;
      if(u.hp <= 0) continue;
      if(!this.canTarget(u)) continue;
      const d = vdist(this.pos, u.mesh.position);
      if(d < bd){ bd = d; best = u; }
    }
    if(best){
      spawnProjectile(this.pos.clone(), best, this.damage, this.team);
      this.cooldown = Math.max(0.02, 1.0 / (this.fireRate || 1.0));
    }
  };

  // -------------------- Projectiles --------------------
  function spawnProjectile(fromVec, targetUnit, power, team){
    const geo = new THREE.SphereGeometry(2.4, 8, 8);
    const mat = new THREE.MeshBasicMaterial({ color: team === 'player' ? 0x99ffcc : 0xffc0c0 });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.copy(fromVec);
    mesh.position.y = 20;
    scene.add(mesh);
    World.projectiles.push({ mesh, target: targetUnit, power, speed: 300, dead: false, team });
  }

  function updateProjectiles(dt){
    for(const p of World.projectiles){
      if(p.dead) continue;
      if(!p.target || p.target.hp <= 0){ p.dead = true; scene.remove(p.mesh); continue; }
      const tpos = p.target.mesh ? p.target.mesh.position : p.target.pos;
      const dx = tpos.x - p.mesh.position.x;
      const dz = tpos.z - p.mesh.position.z;
      const d = Math.sqrt(dx*dx + dz*dz);
      if(d < 3.8){
        // hit
        p.target.hp = Math.max(0, p.target.hp - p.power);
        p.dead = true;
        // tiny impact effect
        spawnImpact(p.mesh.position.clone(), p.team);
        scene.remove(p.mesh);
      } else {
        const nx = dx / d, nz = dz / d;
        const move = p.speed * dt;
        p.mesh.position.x += nx * move; p.mesh.position.z += nz * move;
      }
    }
    for(let i = World.projectiles.length - 1; i >= 0; --i) if(World.projectiles[i].dead) World.projectiles.splice(i,1);
  }

  // simple impact effect
  function spawnImpact(pos, team){
    // small flash (single-frame)
    const geo = new THREE.PlaneGeometry(6,6);
    const mat = new THREE.MeshBasicMaterial({ color: team === 'player' ? 0x99ffcc : 0xffc0c0, transparent:true, opacity:0.9, side: THREE.DoubleSide });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.rotation.x = -Math.PI/2;
    mesh.position.copy(pos); mesh.position.y = 6;
    scene.add(mesh);
    // fade out over 250ms
    const effect = { mesh, life: 0.25 };
    World.effects.push(effect);
  }

  function updateEffects(dt){
    for(const e of World.effects){
      e.life -= dt;
      if(e.mesh && e.mesh.material) e.mesh.material.opacity = Math.max(0, e.life / 0.25);
      if(e.life <= 0){ try{ scene.remove(e.mesh); }catch(_){} }
    }
    for(let i = World.effects.length - 1; i >= 0; --i) if(World.effects[i].life <= 0) World.effects.splice(i,1);
  }

  // -------------------- Troop Class --------------------
  function Troop(opts){
    this.team = opts.team;
    this.name = opts.template.name || 'Troop';
    this.maxHp = opts.template.hp || 200;
    this.hp = this.maxHp;
    this.dmg = opts.template.dmg || 20;
    this.speed = (opts.template.speed || 45) / 60; // world units per second scaled
    this.range = (opts.template.range || 10) / 60;
    this.projectile = !!opts.template.projectile;
    this.size = opts.template.size || 8;
    this.path = opts.path.map(p => p.clone());
    this.waypointIndex = (this.team === 'player') ? 1 : (this.path.length - 2); // start at pre-bridge for player
    this.crossedBridge = false;
    this.mesh = troopMesh(this.team, this.size);
    this.mesh.position.copy(opts.pos);
    this.mesh.position.y = this.size/2;
    const hp = createHealthBar(Math.max(18, this.size*2.2));
    this.mesh.add(hp);
    hp.position.set(0, this.size + 6, 0);
    this.target = null;
    this.state = 'moving';
    this.attackCooldown = 0;
    this.id = 'troop-' + Math.random().toString(36).slice(2,9);
    scene.add(this.mesh);
    World.troops.push(this);
  }

  Troop.prototype.updateVisual = function(){
    const front = this.mesh.children[0].getObjectByName('hpFront');
    if(front){
      const pct = clamp(this.hp / this.maxHp, 0, 1);
      front.scale.x = pct;
      front.position.x = -( (front.geometry.parameters.width) * (1 - pct) ) / 2;
    }
    // color/opacity tweak when low HP
    if(this.hp <= 0 && this.mesh.material) this.mesh.material.opacity = 0.4;
  };

  Troop.prototype.findTarget = function(){
    // prefer nearby enemy troops, then towers
    let best = null, bd = Infinity;
    for(const u of World.troops){
      if(u.team === this.team || u.hp <= 0) continue;
      const d = vdist(this.mesh.position, u.mesh.position);
      if(d < bd){ bd = d; best = u; }
    }
    if(best) return best;
    for(const t of World.towers){
      if(t.team === this.team || t.hp <= 0) continue;
      const d = vdist(this.mesh.position, t.pos);
      if(d < bd){ bd = d; best = t; }
    }
    return best;
  };

  Troop.prototype.update = function(dt){
    if(this.hp <= 0) return;
    if(this.target && this.target.hp <= 0){ this.target = null; this.state = 'moving'; }
    if(!this.target) this.target = this.findTarget();

    // update crossedBridge flag (robust world-position check vs post-bridge z)
    if(this.path && this.path[2]){
      const postZ = this.path[2].z;
      if(this.team === 'player'){
        if(this.mesh.position.z <= postZ + 1) this.crossedBridge = true;
      } else {
        if(this.mesh.position.z >= postZ - 1) this.crossedBridge = true;
      }
    }

    // 1) melee vs troop
    const enemies = World.troops.filter(t => t.team !== this.team && t.hp > 0);
    for(const e of enemies){
      const d = vdist(this.mesh.position, e.mesh.position);
      if(d <= (this.size + e.size) / 2 + 1.2){
        if(this.attackCooldown <= 0){
          this.attackCooldown = 1.0; // basic attack rate
          e.hp = Math.max(0, e.hp - this.dmg);
          // impact
          spawnImpact(this.mesh.position.clone(), this.team);
        }
        return; // stop moving this frame while attacking
      }
    }

    // 2) attack towers if touching / within close distance
    for(const tw of World.towers){
      if(tw.team === this.team || tw.hp <= 0) continue;
      const d = vdist(this.mesh.position, tw.pos);
      if(d <= (this.size / 2) + 14 + 1.2){
        if(this.attackCooldown <= 0){
          this.attackCooldown = 1.0;
          tw.hp = Math.max(0, tw.hp - this.dmg);
          spawnImpact(this.mesh.position.clone(), this.team);
        }
        return;
      }
    }

    // 3) movement along path / to target
    if(this.state === 'moving'){
      if(this.waypointIndex >= this.path.length){
        // no more waypoints, move to target if present
        if(this.target) this.moveToward(this.target.mesh ? this.target.mesh.position : this.target.pos, dt);
      } else {
        const wp = this.path[this.waypointIndex];
        const dwp = vdist(this.mesh.position, wp);
        if(dwp < 2.5) this.waypointIndex++;
        else this.moveToward(wp, dt);
      }
    }

    if(this.attackCooldown > 0) this.attackCooldown -= dt;
  };

  Troop.prototype.moveToward = function(vec, dt){
    const cur = this.mesh.position;
    const dx = vec.x - cur.x, dz = vec.z - cur.z;
    const d = Math.sqrt(dx*dx + dz*dz);
    if(d < 0.001) return;
    const nx = dx / d, nz = dz / d;
    const move = Math.min(this.speed * dt * 60, d);
    this.mesh.position.x += nx * move;
    this.mesh.position.z += nz * move;
    this.mesh.position.y = this.size / 2;
  };

  // -------------------- Game State & AI --------------------
  const Game = {
    elixir: 4, elixirMax: 10, elixirRate: 1, paused: false,
    placementZone: { xMin: -92, xMax: 92, zMin: ARENA_H/2 - 160, zMax: ARENA_H/2 - 30 },
    deckTemplates: [
      { name: 'Knight', hp: 420, dmg: 48, speed: 40, range: 8, projectile: false, cost: 3, size: 10 },
      { name: 'Archer', hp: 200, dmg: 28, speed: 56, range: 120, projectile: true, cost: 3, size: 6 },
      { name: 'Giant', hp: 1100, dmg: 62, speed: 32, range: 12, projectile: false, cost: 5, size: 14 },
      { name: 'Hog', hp: 320, dmg: 60, speed: 115, range: 10, projectile: false, cost: 4, size: 10 },
      { name: 'Minis', hp: 140, dmg: 18, speed: 85, range: 8, projectile: false, cost: 2, size: 6 },
    ],
    selectedCard: null,
    ai: { elixir: 4, spawnIntervalMin: 1.2, spawnIntervalMax: 3.0, lastSpawnAttempt: 0 }
  };

  function spawnAllTowers(){
    // clear previous
    for(const t of World.towers){ try{ scene.remove(t.mesh); scene.remove(t.hpBar);}catch(e){} }
    World.towers.length = 0;
    // player side (bottom / positive z)
    const pLeft = new Tower({ team: 'player', kind: 'princess', pos: new THREE.Vector3(-64, 0, ARENA_H/2 - 92) });
    const pRight = new Tower({ team: 'player', kind: 'princess', pos: new THREE.Vector3(64, 0, ARENA_H/2 - 92) });
    const pKing = new Tower({ team: 'player', kind: 'king', pos: new THREE.Vector3(0, 0, ARENA_H/2 - 44) });
    // enemy side (top / negative z)
    const eLeft = new Tower({ team: 'enemy', kind: 'princess', pos: new THREE.Vector3(-64, 0, -ARENA_H/2 + 92) });
    const eRight = new Tower({ team: 'enemy', kind: 'princess', pos: new THREE.Vector3(64, 0, -ARENA_H/2 + 92) });
    const eKing = new Tower({ team: 'enemy', kind: 'king', pos: new THREE.Vector3(0, 0, -ARENA_H/2 + 44) });
    World.towers.push(pLeft, pRight, pKing, eLeft, eRight, eKing);
    for(const t of World.towers) t.updateVisual();
  }

  function spawnTroopFromCard(card, worldPos){
    // check placement zone
    if(worldPos.z < Game.placementZone.zMin || worldPos.z > Game.placementZone.zMax ||
       worldPos.x < Game.placementZone.xMin || worldPos.x > Game.placementZone.xMax){
      log('Placement outside allowed area'); return;
    }
    if(Game.elixir < card.cost){ log('Not enough elixir'); return; }
    Game.elixir -= card.cost; updateElixirUI();
    const laneName = worldPos.x < 0 ? 'left' : 'right';
    const lane = Lanes[laneName];
    const spawnPos = worldPos.clone(); spawnPos.y = 0;
    // snap spawn z into spawn band to avoid placing inside river
    spawnPos.z = clamp(spawnPos.z, Game.placementZone.zMin, Game.placementZone.zMax);
    const tpl = { ...card }; // copy
    const t = new Troop({ team: 'player', template: tpl, pos: spawnPos, path: lane });
    t.name = tpl.name;
    t.maxHp = tpl.hp; t.hp = tpl.hp; t.dmg = tpl.dmg;
    t.speed = tpl.speed; t.range = tpl.range; t.projectile = !!tpl.projectile;
    log('Player spawned', t.name, 'at', Math.round(spawnPos.x), Math.round(spawnPos.z));
  }

  function aiTick(dt){
    Game.ai.elixir = clamp(Game.ai.elixir + Game.elixirRate * dt, 0, Game.elixirMax);
    Game.ai.lastSpawnAttempt += dt;
    const next = randRange(Game.ai.spawnIntervalMin, Game.ai.spawnIntervalMax);
    if(Game.ai.lastSpawnAttempt >= next){
      Game.ai.lastSpawnAttempt = 0;
      const candidate = Game.deckTemplates[Math.floor(Math.random() * Game.deckTemplates.length)];
      if(Game.ai.elixir >= candidate.cost){
        const laneChoice = Math.random() < 0.5 ? 'left' : 'right';
        const lane = Lanes[laneChoice];
        const spawnPos = lane[lane.length - 1].clone();
        spawnPos.x += (Math.random() - 0.5) * 28;
        aiSpawnTroop(candidate, spawnPos, lane);
        Game.ai.elixir -= candidate.cost;
        log('AI spawned', candidate.name, 'on', laneChoice);
      }
    }
  }

  function aiSpawnTroop(card, worldPos, path){
    const spawnPos = worldPos.clone(); spawnPos.y = 0;
    const t = new Troop({ team: 'enemy', template: card, pos: spawnPos, path: path });
    t.name = card.name;
    t.maxHp = card.hp; t.hp = card.hp; t.dmg = card.dmg; t.speed = card.speed; t.range = card.range; t.projectile = !!card.projectile;
  }

  // -------------------- Input -> World raycast --------------------
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();
  function screenToWorld(x, y){
    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((x - rect.left) / rect.width) * 2 - 1;
    mouse.y = - ((y - rect.top) / rect.height) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const plane = new THREE.Plane(new THREE.Vector3(0,1,0), 0);
    const p = new THREE.Vector3(); raycaster.ray.intersectPlane(plane, p);
    return p;
  }

  renderer.domElement.addEventListener('pointerdown', (ev) => {
    const p = screenToWorld(ev.clientX, ev.clientY);
    if(Game.selectedCard){
      spawnTroopFromCard(Game.selectedCard, p);
      Game.selectedCard = null; highlightSelected(null);
    }
  });

  // -------------------- Deck UI --------------------
  const deckEl = document.getElementById('deck');
  function buildDeckUI(){
    deckEl.innerHTML = '';
    for(const tpl of Game.deckTemplates){
      const d = document.createElement('div');
      d.className = 'card';
      d.innerHTML = `<div style="font-weight:700">${tpl.name}</div><div class="muted">${tpl.cost} elixir</div>`;
      d.addEventListener('click', () => {
        if(Game.elixir >= tpl.cost){ Game.selectedCard = tpl; highlightSelected(d); }
        else log('Not enough elixir');
      });
      deckEl.appendChild(d);
    }
  }
  function highlightSelected(node){
    Array.from(deckEl.children).forEach(c => c.style.boxShadow = '');
    if(node) node.style.boxShadow = '0 0 0 4px rgba(50,200,255,0.12)';
  }
  function updateElixirUI(){
    const pct = Math.round((Game.elixir / Game.elixirMax) * 100);
    document.getElementById('elixirFill').style.width = pct + '%';
    document.getElementById('elixirText').innerText = 'Elixir: ' + Math.floor(Game.elixir) + ' / ' + Game.elixirMax;
    Array.from(deckEl.children).forEach((c,i) => {
      const tpl = Game.deckTemplates[i];
      if(Game.elixir < tpl.cost) c.classList.add('disabled'); else c.classList.remove('disabled');
    });
  }

  // -------------------- Cleanup helpers --------------------
  function cleanupDead(){
    for(let i = World.troops.length - 1; i >= 0; --i){
      if(World.troops[i].hp <= 0){
        try{ scene.remove(World.troops[i].mesh); }catch(e){}
        World.troops.splice(i,1);
      }
    }
    for(let i = World.projectiles.length - 1; i >= 0; --i){
      if(World.projectiles[i].dead){
        try{ scene.remove(World.projectiles[i].mesh); }catch(e){}
        World.projectiles.splice(i,1);
      }
    }
    // effects cleanup handled in updateEffects
  }

  // -------------------- Main Loop --------------------
  let last = now();
  function animate(){
    requestAnimationFrame(animate);
    const t = now();
    const dt = clamp(t - last, 0, 0.06);
    last = t;
    if(!Game.paused){
      Game.elixir = clamp(Game.elixir + Game.elixirRate * dt, 0, Game.elixirMax);
      updateElixirUI();
      aiTick(dt);
      // towers fire
      for(const tw of World.towers) tw.tryFire(dt);
      // projectiles update
      updateProjectiles(dt);
      // troops update
      for(const u of World.troops) u.update(dt);
      // update visuals & cleanup
      for(const t of World.towers) t.updateVisual();
      for(const u of World.troops) u.updateVisual();
      updateEffects(dt);
      cleanupDead();
      // check kings
      const pKing = World.towers.find(t => t.team === 'player' && t.kind === 'king');
      const eKing = World.towers.find(t => t.team === 'enemy' && t.kind === 'king');
      if(pKing && pKing.hp <= 0){ Game.paused = true; log('Enemy wins!'); }
      if(eKing && eKing.hp <= 0){ Game.paused = true; log('Player wins!'); }
    }
    controls.update();
    renderer.render(scene, camera);
  }

  // -------------------- Buttons --------------------
  document.getElementById('btnPause').addEventListener('click', () => { Game.paused = !Game.paused; document.getElementById('btnPause').innerText = Game.paused ? 'Resume' : 'Pause'; });
  document.getElementById('btnStep').addEventListener('click', () => { if(Game.paused){ Game.paused = false; last = now(); setTimeout(()=>{ Game.paused = true; }, 30); } });
  document.getElementById('btnReset').addEventListener('click', () => {
    for(const t of World.towers){ try{ scene.remove(t.mesh); scene.remove(t.hpBar); }catch(_){} }
    for(const u of World.troops){ try{ scene.remove(u.mesh); }catch(_){} }
    for(const p of World.projectiles){ try{ scene.remove(p.mesh); }catch(_){} }
    for(const e of World.effects){ try{ scene.remove(e.mesh); }catch(_){} }
    World.troops.length = 0; World.towers.length = 0; World.projectiles.length = 0; World.effects.length = 0;
    Game.elixir = 4; Game.ai.elixir = 4; updateElixirUI();
    spawnAllTowers(); buildDeckUI(); Game.selectedCard = null; highlightSelected(null);
    log('World reset');
  });

  // debug toggle
  const debugToggle = document.getElementById('debugToggle');
  debugToggle.addEventListener('change', (e) => { debugMarkers.visible = e.target.checked; });

  // -------------------- Initialization --------------------
  Game.recomputePlacementZones = function(){ const m = 1.4; const baseW = 170, baseH = 140; const w = baseW * m, h = baseH * m; this.placementZone.xMin = -w/2; this.placementZone.xMax = w/2; this.placementZone.zMin = ARENA_H/2 - h - 10; this.placementZone.zMax = ARENA_H/2 - 30; };

  // tiny helper: pre-add two default troops for visual reference (optional)
  function spawnDemoTroops(){
    // spawn a couple of friendly + enemy units to test
    const leftSpawn = Lanes.left[0].clone(); leftSpawn.x += -6; leftSpawn.z += -2; const t1 = new Troop({ team:'player', template: Game.deckTemplates[0], pos:leftSpawn, path:Lanes.left }); t1.name='DemoKnight';
    const rightSpawn = Lanes.right[Lanes.right.length-1].clone(); rightSpawn.x += 6; rightSpawn.z += 2; const t2 = new Troop({ team:'enemy', template: Game.deckTemplates[1], pos:rightSpawn, path:Lanes.right }); t2.name='DemoArcher';
  }

  // expose internals for debugging in console
  window.ClashMega = { scene, camera, renderer, World, Game, Lanes, debugMarkers };

  // bootstrap
  Game.recomputePlacementZones();
  spawnAllTowers();
  buildDeckUI();
  updateElixirUI();
  // optional demo troops: uncomment if you want an immediate visual
  // spawnDemoTroops();
  animate();
  log('MEGA 3D loaded — full visuals + pathing + combat. Debug markers are off by default.');

  </script>
</body>
</html>
