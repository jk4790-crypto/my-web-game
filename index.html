<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Mini Royale â€” Ultimate Beast (Full)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
:root{
  --bg-top:#cfefff; --bg-bottom:#9fd8ff;
  --ui-bg:#ffffffee; --accent:#2b7fb2;
  --player:#2f8fe6; --cpu:#e24b4b; --hp:#34c759; --muted:#56616e;
  --font: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
}
html,body{height:100%;margin:0;font-family:var(--font);background:linear-gradient(180deg,var(--bg-top),var(--bg-bottom));display:flex;align-items:center;justify-content:center;}
#root{width:1120px;max-width:98vw;padding:18px;}
header{display:flex;align-items:center;justify-content:space-between;margin-bottom:12px}
h1{margin:0;font-size:20px;color:#063a5b}
button{background:var(--accent);color:white;border:none;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:700}
#gameWrap{display:flex;gap:14px;align-items:flex-start}
canvas{background:#e9fbef;border-radius:12px;border:6px solid #2d6f9b;box-shadow:0 12px 30px rgba(0,0,0,0.12)}
#uiCol{width:360px;display:flex;flex-direction:column;gap:12px}
.panel{background:var(--ui-bg);border-radius:12px;padding:12px;box-shadow:0 8px 20px rgba(10,20,30,0.06)}
#elixirBar{height:22px;border-radius:12px;background:#eaf6ff;border:1px solid #cbeefc;overflow:hidden}
#elixirFill{height:100%;background:linear-gradient(var(--player),#2b7fb2);width:0%}
#elixirCount{font-weight:800;margin-top:6px;text-align:center}
#hand{display:flex;gap:8px;justify-content:center;margin-top:8px;flex-wrap:wrap}
.card{width:84px;height:110px;border-radius:10px;background:white;border:2px solid #e3e7ea;box-shadow:0 8px 20px rgba(0,0,0,0.06);display:flex;flex-direction:column;align-items:center;justify-content:center;cursor:pointer;user-select:none;transition:all .12s}
.card:hover{transform:translateY(-6px);box-shadow:0 12px 26px rgba(0,0,0,0.12)}
.card.selected{outline:3px solid #60b8ff;transform:translateY(-8px)}
.card .name{font-size:13px;font-weight:700;margin-bottom:6px}
.card .cost{font-weight:900;font-size:15px}
.small{font-size:12px;color:var(--muted)}
#controls{display:flex;gap:8px;align-items:center;justify-content:space-between;margin-top:8px}
#log{height:260px;overflow:auto;font-family:monospace;font-size:12px;background:#fff;padding:8px;border-radius:8px;border:1px solid #eee}
#overlay{position:absolute;left:0;top:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
.modal{background:rgba(0,0,0,0.6);color:white;padding:26px;border-radius:12px;text-align:center;pointer-events:auto}
.preview-label{position:fixed;background:#fff;padding:6px 10px;border-radius:8px;border:1px solid #eee;font-weight:700;box-shadow:0 6px 12px rgba(0,0,0,0.10);pointer-events:none}
footer{margin-top:12px;font-size:12px;color:var(--muted)}
@media (max-width:1100px){ #root{padding:8px} #uiCol{display:none} canvas{width:100%} }
</style>
</head>
<body>
<div id="root">
  <header>
    <h1>Mini Royale â€” Ultimate Beast</h1>
    <div style="display:flex;gap:10px;align-items:center">
      <div class="small">All systems: Lanes â€¢ Towers â€¢ Dragon â€¢ CPU â€¢ Elixir</div>
      <button id="restartBtn">Restart</button>
    </div>
  </header>

  <div id="gameWrap">
    <div style="position:relative">
      <canvas id="canvas" width="800" height="600"></canvas>
      <div id="overlay" style="width:800px;height:600px"></div>
    </div>

    <div id="uiCol">
      <div class="panel">
        <div style="display:flex;justify-content:space-between;align-items:center;">
          <strong>Elixir</strong>
          <div id="clock" class="small">00:00</div>
        </div>
        <div style="margin-top:8px" id="elixirBar"><div id="elixirFill"></div></div>
        <div id="elixirCount" class="small">5 / 10</div>
        <div style="margin-top:10px;font-size:12px;color:var(--muted)">Left/Right lanes. Troops: units â†’ lane tower â†’ king (per-lane unlock).</div>
      </div>

      <div class="panel">
        <div style="display:flex;justify-content:space-between;align-items:center;">
          <strong>Your hand</strong>
          <div class="small">3 visible â€¢ Dragon â€¢ Fireball â€¢ Cannon â€¢ Skeletons</div>
        </div>
        <div id="hand"></div>
        <div id="controls">
          <div class="small" id="crowns">Crowns: 0 - 0</div>
          <div style="display:flex;gap:6px">
            <button id="pickLeft" class="small">Left</button>
            <button id="pickRight" class="small">Right</button>
          </div>
        </div>
      </div>

      <div class="panel">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <strong>Battle log</strong>
          <div class="small">events</div>
        </div>
        <div id="log"></div>
      </div>
    </div>
  </div>

  <footer>Drop into GitHub Pages â€” one monolith.</footer>
</div>

<div id="previewLabel" class="preview-label" style="display:none">Preview</div>

<script>
/*
  Ultimate Beast single-file game with:
  - two lanes (left/right)
  - lane-specific princess towers + king tower per side
  - per-lane king unlocks: when that lane's princess dies, that lane's troops target King
  - towers attack (princess & king)
  - dragon projectile fix (canHitFlying/canHitGround)
  - elixir & hand, CPU AI, projectiles, spell splash
  - plenty of FIX comments for where important fixes are applied
*/

// ---------- CONFIG ----------
const CONFIG = {
  W: 800, H: 600,
  lanes: {
    left: { spawnXPlayer: 200, spawnXCPU: 200, laneX: 200 },
    right:{ spawnXPlayer: 600, spawnXCPU: 600, laneX: 600 },
    playerSpawnY: 520, cpuSpawnY: 80
  },
  princessY: { player: 500, cpu: 100 },
  kingY: { player: 550, cpu: 50 },
  leftX: 200, rightX: 600, midX: 400,
  elixir: { start:5, max:10, regenMs:2800, doubleAfterMs:120000, doubleRegenMs:1400 },
  cpuAttemptMin: 2200, cpuAttemptMax: 5200,
  deckVisible: 3
};

// ---------- HELPERS ----------
function uid(){ return Math.random().toString(36).slice(2,9); }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function now(){ return performance.now(); }
function randRange(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function shuffle(a){ const arr=a.slice(); for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]];} return arr; }

// ---------- DOM ----------
const canvas = document.getElementById('canvas'), ctx = canvas.getContext('2d');
canvas.width = CONFIG.W; canvas.height = CONFIG.H;
const elixirFill = document.getElementById('elixirFill');
const elixirCount = document.getElementById('elixirCount');
const clockEl = document.getElementById('clock');
const handEl = document.getElementById('hand');
const logEl = document.getElementById('log');
const crownsEl = document.getElementById('crowns');
const overlay = document.getElementById('overlay');
const previewLabel = document.getElementById('previewLabel');

document.getElementById('restartBtn').onclick = ()=> initGame();
document.getElementById('pickLeft').onclick = ()=> { if(state) state.selectedLane='left'; flashLabel('Left lane'); };
document.getElementById('pickRight').onclick = ()=> { if(state) state.selectedLane='right'; flashLabel('Right lane'); };

// ---------- CATALOG ----------
const CATALOG = [
  { key:'knight', name:'Knight', cost:3, hp:160, dmg:46, speed:48, range:18, size:14, type:'melee', aggro:60 },
  { key:'archer', name:'Archer', cost:3, hp:80, dmg:28, speed:84, range:140, size:10, type:'ranged', projectile:'purple', aggro:90 },
  { key:'miniTank', name:'MiniTank', cost:5, hp:320, dmg:70, speed:30, range:20, size:18, type:'melee', aggro:40 },
  { key:'goblin', name:'Goblin', cost:2, hp:70, dmg:34, speed:120, range:14, size:10, type:'melee', aggro:44 },
  { key:'bomber', name:'Bomber', cost:4, hp:120, dmg:90, speed:36, range:22, size:15, type:'splash', splash:30, aggro:70 },
  { key:'healer', name:'Healer', cost:4, hp:110, dmg:0, speed:44, range:48, size:13, type:'healer', heal:18, aggro:60 },
  { key:'cannon', name:'Cannon', cost:4, hp:700, dmg:80, speed:1.0, range:120, size:22, type:'building', keyName:'cannon' },
  { key:'fireball', name:'Fireball', cost:4, dmg:160, splash:70, type:'spell' },
  { key:'dragon', name:'Dragon', cost:5, hp:420, dmg:48, speed:46, range:110, size:30, type:'flying', isFlying:true, projectile:'fire', splash:36 },
  { key:'skeleton_swarm', name:'Skeletons', cost:3, hp:28, dmg:28, speed:110, range:14, size:8, type:'melee', swarmCount:7 }
];

// ---------- STATE ----------
let state = null;

// ---------- CLASSES ----------
class Entity {
  constructor(x,y,owner){ this.id = uid(); this.x=x; this.y=y; this.owner=owner; this.hp=1; this.maxHp=1; this.alive=true; }
}
class Unit extends Entity {
  constructor(card,x,y,owner,lane){
    super(x,y,owner);
    this.cardKey = card.key; this.name = card.name;
    this.hp = card.hp; this.maxHp = card.hp;
    this.dmg = card.dmg || 0; this.speed = card.speed || 36;
    this.range = card.range || 20; this.size = card.size || 12;
    this.type = card.type; this.spawnTime = now();
    this.atkCooldown = 0; this.atkSpeed = 1.0; this.aggroRadius = card.aggro || 60;
    this.target = null; this.lane = lane; this.isFlying = !!card.isFlying; this.splash = card.splash || 0; this.projectileType = card.projectile || null;
    if(card.key === 'dragon'){ this.atkSpeed = 0.8; this.projectileType = 'fire'; this.splash = card.splash || 36; }
  }
}
class Tower extends Entity {
  constructor(x,y,owner,isKing=false,lane=null){
    super(x,y,owner);
    this.isKing = !!isKing; this.lane = lane; this.r = isKing ? 34 : 28;
    this.hp = isKing ? 1600 : 700; this.maxHp = this.hp;
    this.dmg = isKing ? 95 : 75; this.range = 170; this.attackSpeed = 1.1; this.attackCooldown = 0;
  }
}
class Projectile {
  constructor(x,y,opts){
    this.id = uid(); this.x=x; this.y=y;
    this.destX = opts.destX || null; this.destY = opts.destY || null;
    this.targetId = opts.targetId || null; this.targetType = opts.targetType || null;
    this.dmg = opts.dmg || 0; this.splash = opts.splash || 0; this.speed = opts.speed || 520;
    this.owner = opts.owner; this.kind = opts.kind || 'bullet'; this.color = opts.color || 'yellow';
    this.born = now(); this.canHitFlying = !!opts.canHitFlying; this.canHitGround = !!opts.canHitGround;
  }
}

// ---------- INIT ----------
function initGame(){
  overlay.innerHTML=''; previewLabel.style.display='none';
  state = {
    timeMs: 0, lastFrame: now(),
    elixir: CONFIG.elixir.start, elixirTick: 0,
    cpuElixir: CONFIG.elixir.start, cpuElixirTick: 0,
    playerDeck: shuffle(CATALOG.map(c => ({...c, uid: uid()}))),
    cpuDeck: shuffle(CATALOG.map(c => ({...c, uid: uid()}))),
    selectedCardIndex: null, selectedLane: 'left', preview: null,
    units: [], projectiles: [], buildings: [],
    playerTowers: [], cpuTowers: [],
    cpuTimer: 0, cpuNextAttempt: randRange(CONFIG.cpuAttemptMin, CONFIG.cpuAttemptMax),
    crowns: { player:0, cpu:0 }, running: true, timeStarted: now(),
    // FIX: per-lane king unlocks so only that lane's troops retarget king
    kingUnlock: { player: { left:false, right:false }, cpu: { left:false, right:false } }
  };

  // Correct tower positions (FIX applied)
  state.playerTowers = [
    new Tower(CONFIG.leftX, CONFIG.princessY.player, 'player', false, 'left'),
    new Tower(CONFIG.rightX, CONFIG.princessY.player, 'player', false, 'right'),
    new Tower(CONFIG.midX, CONFIG.kingY.player, 'player', true, null)
  ];
  state.cpuTowers = [
    new Tower(CONFIG.leftX, CONFIG.princessY.cpu, 'cpu', false, 'left'),
    new Tower(CONFIG.rightX, CONFIG.princessY.cpu, 'cpu', false, 'right'),
    new Tower(CONFIG.midX, CONFIG.kingY.cpu, 'cpu', true, null)
  ];

  state.buildings = [...state.playerTowers, ...state.cpuTowers];

  renderHand(); logClear(); log('Match started â€” The Ultimate Beast!');
  updateElixirUI(); crownsEl.textContent = `Crowns: ${state.crowns.player} - ${state.crowns.cpu}`;
  state.lastFrame = now();
  requestAnimationFrame(loop);
}

// ---------- UI ----------
function renderHand(){
  handEl.innerHTML = '';
  const visible = state.playerDeck.slice(0, CONFIG.deckVisible);
  visible.forEach((card, i) => {
    const div = document.createElement('div');
    div.className = 'card' + (state.selectedCardIndex === i ? ' selected' : '');
    div.innerHTML = `<div class="name">${card.name}</div><div class="cost">${card.cost} â¬¤</div>`;
    div.onclick = () => {
      if(!state.running) return;
      state.selectedCardIndex = (state.selectedCardIndex === i) ? null : i;
      if(state.selectedCardIndex !== null){
        const c = state.playerDeck[state.selectedCardIndex];
        state.preview = { x: CONFIG.midX*0.5, y: (state.selectedLane==='left'?CONFIG.princessY.player - 40:CONFIG.princessY.player - 40), card: c };
        previewLabel.style.display = 'block';
        previewLabel.textContent = `${c.name} â€¢ ${c.cost} â¬¤`;
      } else { state.preview = null; previewLabel.style.display = 'none'; }
      renderHand();
    };
    handEl.appendChild(div);
  });
}

function logClear(){ logEl.innerHTML=''; }
function log(txt){ const d=document.createElement('div'); d.textContent=`[${Math.floor(state.timeMs/1000)}s] ${txt}`; logEl.prepend(d); if(logEl.children.length>400) logEl.removeChild(logEl.lastChild); }
function flashLabel(msg){ previewLabel.style.display='block'; previewLabel.textContent=msg; previewLabel.style.left=(window.innerWidth/2+120)+'px'; previewLabel.style.top='18px'; setTimeout(()=>{ if(state && state.selectedCardIndex!==null) previewLabel.style.display='block'; else previewLabel.style.display='none'; },900); }

// ---------- INPUT ----------
canvas.addEventListener('mousemove', (ev) => {
  if(!state || state.selectedCardIndex === null) return;
  const rect = canvas.getBoundingClientRect();
  const mx = (ev.clientX - rect.left) * (canvas.width / rect.width);
  const my = (ev.clientY - rect.top) * (canvas.height / rect.height);
  const card = state.playerDeck[state.selectedCardIndex];
  if(card.type === 'spell'){
    state.preview = { x: clamp(mx, 40, canvas.width - 40), y: clamp(my, 40, canvas.height - 40), card };
  } else {
    if(mx > canvas.width/2){ state.preview = null; previewLabel.style.display='none'; return; }
    const lane = (mx < canvas.width/4) ? 'left' : 'right';
    const laneY = (lane==='left') ? CONFIG.princessY.player - 80 : CONFIG.princessY.player - 80;
    state.preview = { x: clamp(mx, 60, canvas.width/2 - 60), y: laneY, card };
  }
  previewLabel.style.display = 'block';
  previewLabel.style.left = (ev.clientX + 10) + 'px';
  previewLabel.style.top = (ev.clientY + 8) + 'px';
  previewLabel.textContent = `${card.name} â€¢ ${card.cost} â¬¤`;
});

canvas.addEventListener('click', (ev) => {
  const rect = canvas.getBoundingClientRect();
  const mx = ev.clientX - rect.left;
  // Determine lane by x click (left half left lane, right half right lane)
  const lane = (mx < canvas.width/2) ? 'left' : 'right';

  // If player has selected a card, place that card in selected lane at player spawn Y
  if(state && state.selectedCardIndex !== null && state.preview){
    const card = state.playerDeck[state.selectedCardIndex];
    if(state.elixir < card.cost){ log('Not enough elixir for ' + card.name); return; }

    // Spell: Fireball (spell has target x/y)
    if(card.type === 'spell' && card.key === 'fireball'){
      const targetX = state.preview.x, targetY = state.preview.y;
      // FIX: spells can hit flying & ground here (design choice)
      spawnSpellProjectile(120, CONFIG.H/2, { x: targetX, y: targetY }, card.dmg, card.splash, 'orange', 'player', true, true);
      state.elixir -= card.cost;
    } else if(card.type === 'building'){
      spawnBuilding(card, (lane==='left')?CONFIG.leftX:CONFIG.rightX, (lane==='left')?CONFIG.princessY.player:CONFIG.princessY.player, 'player');
      state.elixir -= card.cost;
    } else if(card.key === 'skeleton_swarm'){
      spawnSkeletonSwarm((lane==='left')?CONFIG.leftX:CONFIG.rightX, (lane==='left')?CONFIG.princessY.player - 80:CONFIG.princessY.player - 80, 'player', lane, card.swarmCount || 7);
      state.elixir -= card.cost;
    } else if(card.key === 'dragon'){
      spawnUnit(card, (lane==='left')?CONFIG.leftX:CONFIG.rightX, CONFIG.princessY.player - 100, 'player', lane);
      state.elixir -= card.cost;
    } else {
      spawnUnit(card, (lane==='left')?CONFIG.leftX:CONFIG.rightX, CONFIG.princessY.player - 80, 'player', lane);
      state.elixir -= card.cost;
    }

    // cycle card & reset selection
    const used = state.playerDeck.splice(state.selectedCardIndex,1)[0];
    state.playerDeck.push({...used, uid: uid()});
    state.selectedCardIndex = null; state.preview = null; previewLabel.style.display='none';
    renderHand(); updateElixirUI();
    return;
  }

  // If no card selected: quick spawn cheap unit (for testing) using 2 elixir
  if(state.elixir >= 2){
    spawnUnit(CATALOG[3], (lane==='left')?CONFIG.leftX:CONFIG.rightX, CONFIG.princessY.player - 80, 'player', lane); // goblin
    state.elixir -= 2;
    updateElixirUI();
  }
});

// ---------- SPAWNS ----------
function spawnBuilding(card, x, y, owner){
  const b = { id: uid(), key: card.key, name: card.name, owner, x, y, hp: card.hp, maxHp: card.hp, dmg: card.dmg || 0, range: card.range || 0, size: card.size || 18, alive: true, type:'building' };
  state.buildings.push(b);
  log(`${owner === 'player' ? 'You' : 'CPU'} built ${card.name}`);
  return b;
}

function spawnUnit(card, x, y, owner, lane){
  const u = new Unit(card, x + (owner==='player'? randRange(-10,10) : randRange(-10,10)), y, owner, lane);
  state.units.push(u);
  log(`${owner === 'player' ? 'You' : 'CPU'} deployed ${u.name} (${lane})`);
  return u;
}

function spawnSkeletonSwarm(cx, cy, owner, lane, count=7){
  for(let i=0;i<count;i++){
    const ang = Math.random()*Math.PI*2;
    const r = 8 + Math.random()*20;
    const x = clamp(cx + Math.cos(ang)*r + (Math.random()-0.5)*6, 60, canvas.width/2 - 60);
    const y = cy + (Math.random()-0.5)*18;
    const skCard = {...CATALOG.find(c=>c.key==='skeleton_swarm')};
    const skUnit = new Unit(skCard, x, y, owner, lane);
    skUnit.cardKey = 'skeleton'; skUnit.name = 'Skeleton';
    state.units.push(skUnit);
  }
  log(`${owner === 'player' ? 'You' : 'CPU'} spawned Skeleton Swarm (${count})`);
}

// ---------- PROJECTILES ----------
// FIX: projectiles carry canHitFlying/canHitGround flags to avoid incorrect splash damage
function spawnProjectile(fromX, fromY, targetObj, dmg, color, owner, kind='bullet', splash=0, canHitFlying=true, canHitGround=true){
  const p = new Projectile(fromX, fromY, { targetId: targetObj.id, targetType: (state.units.find(u=>u.id===targetObj.id) ? 'unit' : 'building'), dmg, splash, color, owner, kind, canHitFlying, canHitGround });
  state.projectiles.push(p);
  return p;
}
function spawnSpellProjectile(fromX, fromY, dest, dmg, splash, color, owner, canHitFlying=true, canHitGround=true){
  const p = new Projectile(fromX, fromY, { destX: dest.x, destY: dest.y, dmg, splash, color, owner, kind:'spell', canHitFlying, canHitGround });
  state.projectiles.push(p);
  return p;
}

// ---------- CPU ----------
function cpuBehaviorTick(dt){
  state.cpuTimer += dt;
  if(state.cpuTimer < state.cpuNextAttempt) return;
  state.cpuTimer = 0;
  state.cpuNextAttempt = randRange(CONFIG.cpuAttemptMin, CONFIG.cpuAttemptMax);

  const visible = state.cpuDeck.slice(0, CONFIG.deckVisible);
  const affordable = visible.filter(c => c.cost <= state.cpuElixir);
  if(affordable.length === 0) return;

  let pick = affordable[randRange(0, affordable.length-1)];
  if(Math.random() < 0.28){ const cand = affordable.find(c => c.type === 'building'); if(cand) pick = cand; }

  // choose lane biased by state (random for now)
  const lane = Math.random() < 0.5 ? 'left' : 'right';

  if(pick.type === 'spell' && pick.key==='fireball'){
    // target cluster of player units or lane
    let tx = (lane==='left')? CONFIG.leftX : CONFIG.rightX;
    let ty = CONFIG.princessY.player - 80;
    const playerUnits = state.units.filter(u => u.owner === 'player' && u.lane === lane);
    if(playerUnits.length){
      const sample = playerUnits.slice(0, Math.min(4, playerUnits.length));
      tx = sample.reduce((s,u)=>s+u.x,0)/sample.length;
      ty = sample.reduce((s,u)=>s+u.y,0)/sample.length;
    }
    spawnSpellProjectile(120, CONFIG.H/2, { x: tx, y: ty }, pick.dmg, pick.splash, 'orangered', 'cpu', true, true);
    state.cpuElixir -= pick.cost;
  } else if(pick.type === 'building'){
    const sx = (lane==='left')? CONFIG.leftX : CONFIG.rightX;
    spawnBuilding(pick, sx, (lane==='left')?CONFIG.princessY.cpu:CONFIG.princessY.cpu, 'cpu');
    state.cpuElixir -= pick.cost;
  } else if(pick.key === 'skeleton_swarm'){
    const sx = (lane==='left')? CONFIG.leftX : CONFIG.rightX;
    spawnSkeletonSwarm(sx, (lane==='left')?CONFIG.princessY.cpu+40:CONFIG.princessY.cpu+40, 'cpu', lane, pick.swarmCount || 7);
    state.cpuElixir -= pick.cost;
  } else {
    const sx = (lane==='left')? CONFIG.leftX : CONFIG.rightX;
    const sy = (lane==='left')? CONFIG.princessY.cpu+40 : CONFIG.princessY.cpu+40;
    spawnUnit(pick, sx, sy, 'cpu', lane);
    state.cpuElixir -= pick.cost;
  }

  const idx = state.cpuDeck.findIndex(c => c.uid === pick.uid);
  if(idx !== -1){ const used = state.cpuDeck.splice(idx,1)[0]; state.cpuDeck.push({...used, uid: uid()}); }
}

// ---------- SIMULATION ----------
function simulate(dt){
  const sdt = dt/1000;

  // PROJECTILES
  for(let i = state.projectiles.length - 1; i >= 0; i--){
    const p = state.projectiles[i];
    if(p.kind === 'spell'){
      const dx = p.destX - p.x, dy = p.destY - p.y; const dist = Math.hypot(dx,dy);
      const travel = p.speed * sdt;
      if(dist <= travel || dist < 4){
        // explosion: apply splash (respect canHitFlying / canHitGround)
        const targets = state.units.filter(u => {
          const d = Math.hypot(u.x - p.destX, u.y - p.destY);
          if(d > p.splash) return false;
          if(u.isFlying && !p.canHitFlying) return false;
          if(!u.isFlying && !p.canHitGround) return false;
          return true;
        });
        for(const t of targets) t.hp -= p.dmg;
        const builds = state.buildings.filter(b => Math.hypot(b.x - p.destX, b.y - p.destY) <= p.splash && b.alive);
        for(const b of builds) b.hp -= p.dmg;
        state.projectiles.splice(i,1);
        continue;
      } else { p.x += (dx/dist) * travel; p.y += (dy/dist) * travel; }
    } else {
      // homing projectile to target object
      let target = null;
      if(p.targetType === 'unit') target = state.units.find(e => e.id === p.targetId);
      else target = state.buildings.find(b => b.id === p.targetId) || state.playerTowers.concat(state.cpuTowers).find(t => t.id === p.targetId);
      if(!target){ state.projectiles.splice(i,1); continue; }
      const dx = target.x - p.x, dy = target.y - p.y; const dist = Math.hypot(dx,dy);
      const travel = p.speed * sdt;
      if(dist <= travel || dist < 4){
        // hit
        if(p.splash && p.splash > 0){
          const enemies = state.units.filter(e => e.owner !== p.owner && Math.hypot(e.x - target.x, e.y - target.y) <= p.splash && ((e.isFlying && p.canHitFlying) || (!e.isFlying && p.canHitGround)));
          for(const e of enemies) e.hp -= p.dmg;
          const buildsNear = state.buildings.filter(b => b.owner !== p.owner && Math.hypot(b.x - target.x, b.y - target.y) <= p.splash);
          for(const b of buildsNear) b.hp -= p.dmg;
        } else {
          // single-target hit; respect flags for unit targets
          if(p.targetType === 'unit'){
            if((target.isFlying && p.canHitFlying) || (!target.isFlying && p.canHitGround)){
              target.hp -= p.dmg;
            }
          } else {
            target.hp -= p.dmg;
          }
        }
        state.projectiles.splice(i,1); continue;
      } else { p.x += (dx/dist) * travel; p.y += (dy/dist) * travel; }
    }
  }

  // AGGRO & TARGETING (LANE AWARE)
  for(const u of state.units){
    if(u.hp <= 0) continue;
    // cleanup invalid target immediately
    if(u.target){
      const tunit = state.units.find(e => e.id === u.target && e.hp > 0);
      const tbuild = state.buildings.find(b => b.id === u.target && b.hp > 0);
      if(!(tunit || tbuild)) u.target = null;
    }
    if(u.target) continue;

    // helper: can this attacker attack unit?
    function canAttackUnit(attacker, target){
      if(!target) return false;
      if(attacker.projectileType || attacker.type === 'ranged' || attacker.isFlying || attacker.cardKey === 'dragon') return true;
      if(attacker.type === 'melee' && target.isFlying) return false;
      return true;
    }

    // candidate pools for the lane
    const enemyUnits = state.units.filter(e => e.owner !== u.owner && e.hp > 0 && e.lane === u.lane);
    const enemyBuilds = state.buildings.filter(b => b.owner !== u.owner && b.alive);
    const enemyTowers = (u.owner === 'player') ? state.cpuTowers.filter(t=>t.alive) : state.playerTowers.filter(t=>t.alive);
    const enemyOwner = (u.owner === 'player') ? 'cpu' : 'player';
    const laneUnlock = state.kingUnlock[enemyOwner][u.lane];

    // Priority 1: enemy units in same lane
    let nearest = null, nd = 1e9;
    for(const e of enemyUnits){
      if(!canAttackUnit(u,e)) continue;
      const d = Math.hypot(e.x - u.x, e.y - u.y);
      if(d < nd && d <= u.aggroRadius){ nd = d; nearest = e; }
    }
    if(nearest){ u.target = nearest.id; continue; }

    // Priority 2: lane princess tower
    const laneTowers = enemyTowers.filter(t => t.lane === u.lane && !t.isKing && t.alive);
    if(laneTowers.length){
      const cand = laneTowers[0];
      const d = Math.hypot(cand.x - u.x, cand.y - u.y);
      if(d <= u.aggroRadius * 1.2){ u.target = cand.id; continue; }
    }

    // Priority 3: king if lane unlocked (FIX: troops will lock to king per-lane)
    if(laneUnlock){
      const king = enemyTowers.find(t => t.isKing && t.alive);
      if(king){ u.target = king.id; continue; }
    }

    // nothing: remain un-targeted
  }

  // MOVEMENT & ATTACK
  for(const u of state.units){
    if(u.hp <= 0) continue;
    if(u.target){
      const tUnit = state.units.find(e => e.id === u.target && e.hp > 0);
      let tBuild = null;
      if(!tUnit){
        tBuild = state.buildings.find(b => b.id === u.target && b.hp > 0) || state.playerTowers.concat(state.cpuTowers).find(t => t.id === u.target && t.hp > 0);
      }
      if(!tUnit && !tBuild){ u.target = null; continue; }

      // If target is king and lane unlocked, force vertical routing toward king (FIX: move vertically to king)
      if(tBuild && tBuild.isKing){
        const targetX = tBuild.x, targetY = tBuild.y;
        const dx = targetX - u.x, dy = targetY - u.y;
        const ang = Math.atan2(dy, dx);
        u.x += Math.cos(ang) * u.speed * sdt;
        u.y += Math.sin(ang) * u.speed * sdt;
        const d = Math.hypot(targetX - u.x, targetY - u.y);
        if(d <= u.range + (tBuild.r||tBuild.size||18) + 6){
          u.atkCooldown -= dt/1000;
          if(u.atkCooldown <= 0){
            u.atkCooldown = 1 / (u.atkSpeed || 1);
            if(u.projectileType){
              if(u.cardKey === 'dragon'){
                // SPELL: dragon projectile hits both flying & ground (FIX)
                spawnProjectile(u.x, u.y, tBuild, u.dmg, 'orangered', u.owner, 'dragon_proj', u.splash || 36, true, true);
              } else {
                spawnProjectile(u.x, u.y, tBuild, u.dmg, u.projectileType, u.owner, 'unit', u.splash || 0, true, true);
              }
            } else {
              tBuild.hp -= u.dmg;
            }
          }
        }
      } else if(tUnit){
        const d = Math.hypot(tUnit.x - u.x, tUnit.y - u.y);
        if(d <= u.range + u.size + 4){
          u.atkCooldown -= dt/1000;
          if(u.atkCooldown <= 0){
            u.atkCooldown = 1 / (u.atkSpeed || 1);
            if(u.type === 'healer'){
              const allies = state.units.filter(a => a.owner === u.owner && a.lane === u.lane && a.hp > 0 && Math.hypot(a.x - u.x,a.y - u.y) <= u.range);
              for(const a of allies) a.hp = Math.min(a.maxHp, a.hp + (u.heal || 10));
            } else if(u.type === 'splash' && u.splash){
              for(const e of state.units) if(e.owner !== u.owner && !e.isFlying && Math.hypot(e.x - tUnit.x, e.y - tUnit.y) <= u.splash) e.hp -= u.dmg;
            } else if(u.projectileType){
              spawnProjectile(u.x, u.y, tUnit, u.dmg, u.projectileType, u.owner, 'unit', u.splash || 0, true, true);
            } else {
              if(!tUnit.isFlying) tUnit.hp -= u.dmg;
            }
          }
        } else {
          const ang = Math.atan2(tUnit.y - u.y, tUnit.x - u.x);
          u.x += Math.cos(ang) * u.speed * sdt;
          if(!u.isFlying) u.y += ((u.lane==='left'?CONFIG.princessY.player - 80:CONFIG.princessY.player - 80) - u.y) * 0.15;
        }
      } else if(tBuild){
        const tx = tBuild.x, ty = tBuild.y;
        const d = Math.hypot(tx - u.x, ty - u.y);
        if(d <= u.range + (tBuild.r||tBuild.size||18) + 6){
          u.atkCooldown -= dt/1000;
          if(u.atkCooldown <= 0){
            u.atkCooldown = 1 / (u.atkSpeed || 1);
            if(u.projectileType){
              spawnProjectile(u.x, u.y, tBuild, u.dmg, u.projectileType, u.owner, 'unit', u.splash || 0, true, true);
            } else {
              tBuild.hp -= u.dmg;
            }
          }
        } else {
          const ang = Math.atan2(ty - u.y, tx - u.x);
          u.x += Math.cos(ang) * u.speed * sdt;
        }
      }
    } else {
      // no target - move forward in lane toward enemy side
      const dir = (u.owner === 'player') ? -1 : 1; // player moves up (negative y), cpu moves down (positive y)
      // keep X fixed per lane
      const targetLaneX = (u.lane === 'left') ? CONFIG.leftX : CONFIG.rightX;
      u.x += (targetLaneX - u.x) * 0.12; // snap to lane X gradually
      u.y += dir * u.speed * sdt;
    }
  }

  // ---------- TOWERS ATTACK ----------
  const dtSec = dt/1000;
  for(const t of [...state.playerTowers, ...state.cpuTowers]){
    if(!t.alive) continue;
    t.attackCooldown -= dtSec;
    // towers check for enemy units within vertical band to avoid cross-lane targeting too much
    const enemyUnits = state.units.filter(e => e.owner !== t.owner && Math.abs(e.x - t.x) < 180 && e.hp > 0);
    if(enemyUnits.length > 0){
      enemyUnits.sort((a,b)=>Math.hypot(a.x-t.x,a.y-t.y)-Math.hypot(b.x-t.x,b.y-t.y));
      const target = enemyUnits[0]; const d = Math.hypot(target.x - t.x, target.y - t.y);
      if(d <= t.range){
        if(t.attackCooldown <= 0){
          t.attackCooldown = t.attackSpeed;
          // towers fire projectiles that can hit flying & ground (ranged)
          spawnProjectile(t.x, t.y, target, t.dmg, (t.owner==='player'?'blue':'red'), t.owner, 'tower', 0, true, true);
        }
      }
    } else {
      // if no units, towers may attack buildings in range
      const enemyBuilds = state.buildings.filter(b => b.owner !== t.owner && b.alive);
      if(enemyBuilds.length){
        enemyBuilds.sort((a,b)=>Math.hypot(a.x-t.x,a.y-t.y)-Math.hypot(b.x-t.x,b.y-t.y));
        const trg = enemyBuilds[0]; const d2 = Math.hypot(trg.x - t.x, trg.y - t.y);
        if(d2 <= t.range){
          if(t.attackCooldown <= 0){
            t.attackCooldown = t.attackSpeed;
            spawnProjectile(t.x, t.y, trg, t.dmg, (t.owner==='player'?'blue':'red'), t.owner, 'tower', 0, true, true);
          }
        }
      }
    }
  }

  // ---------- CLEANUP ----------
  state.units = state.units.filter(u => u.hp > 0 && u.y > -200 && u.y < canvas.height + 200);
  // projectiles are pruned on impact; keep only ones that remain (we didn't mark alive flag per projectile but remove on hit above)
  // Build/tower death handling and per-lane king unlock
  for(const b of [...state.buildings]){
    if(b.alive && b.hp <= 0){
      b.alive = false;
      log(`${b.owner.toUpperCase()} ${b.lane ? b.lane.toUpperCase() : 'KING'} ${b.isKing ? 'KING' : 'PRINCESS'} destroyed!`);
      if(!b.isKing){
        const victimOwner = b.owner;
        const opp = (victimOwner === 'player') ? 'cpu' : 'player';
        // mark lane-specific king unlock
        state.kingUnlock[opp][b.lane] = true;
        log(`${opp.toUpperCase()} troops on lane ${b.lane.toUpperCase()} will now target the KING tower.`);
      }
    }
  }

  for(const t of [...state.playerTowers, ...state.cpuTowers]){
    if(t.alive && t.hp <= 0){
      t.alive = false;
      if(t.isKing){
        log(`${t.owner.toUpperCase()} king tower destroyed!`);
        const winner = (t.owner === 'player') ? 'cpu' : 'player';
        endMatch(winner, 'King tower destroyed');
        return;
      } else {
        log(`${t.owner.toUpperCase()} princess tower destroyed!`);
        if(t.owner === 'player') state.crowns.cpu++; else state.crowns.player++;
        crownsEl.textContent = `Crowns: ${state.crowns.player} - ${state.crowns.cpu}`;
      }
    }
  }
}

// ---------- END MATCH ----------
function endMatch(winner, reason){
  state.running = false;
  log(`Match ended: ${winner.toUpperCase()} wins â€” ${reason}`);
  overlay.innerHTML = '';
  const modal = document.createElement('div'); modal.className = 'modal';
  modal.style.minWidth = '360px';
  modal.style.pointerEvents = 'auto';
  modal.innerHTML = `
    <div style="background:rgba(0,0,0,0.6);color:white;padding:18px;border-radius:10px;text-align:center">
      <h2 style="margin:8px 0">${winner === 'player' ? 'You Win!' : 'CPU Wins'}</h2>
      <div style="margin:10px 0">${reason}</div>
      <div style="display:flex;gap:8px;justify-content:center">
        <button id="replayBtn" style="padding:8px 12px;border-radius:8px;border:none;background:#2b7fb2;color:white;font-weight:700">Play Again</button>
      </div>
    </div>
  `;
  overlay.appendChild(modal);
  document.getElementById('replayBtn').onclick = ()=> initGame();
}

// ---------- ELIXIR UI ----------
function updateElixirUI(){
  elixirFill.style.width = Math.round((state.elixir / CONFIG.elixir.max) * 100) + '%';
  elixirCount.textContent = `${Math.floor(state.elixir)} / ${CONFIG.elixir.max}`;
}

// ---------- RENDER ----------
function render(){
  ctx.clearRect(0,0,CONFIG.W,CONFIG.H);
  // background lanes & river
  ctx.fillStyle = '#e9f5e9'; ctx.fillRect(0,0,CONFIG.W,CONFIG.H);
  ctx.fillStyle = '#d0f0d6'; ctx.fillRect(0, CONFIG.princessY.cpu - 96, CONFIG.W, 140);
  ctx.fillRect(0, CONFIG.princessY.player - 96, CONFIG.W, 140);
  ctx.fillStyle = 'rgba(90,140,150,0.10)'; ctx.fillRect(CONFIG.W/2 - 16, CONFIG.princessY.cpu - 96, 32, (CONFIG.princessY.player - 96) - (CONFIG.princessY.cpu - 96) + 192);

  // draw king towers behind
  state.playerTowers.filter(t=>t.isKing).forEach(drawTower);
  state.cpuTowers.filter(t=>t.isKing).forEach(drawTower);
  // princess towers
  state.playerTowers.filter(t=>!t.isKing).forEach(drawTower);
  state.cpuTowers.filter(t=>!t.isKing).forEach(drawTower);

  // buildings (cannon etc.)
  state.buildings.filter(b => b.alive && b.key==='cannon').forEach(drawBuilding);

  // projectiles
  for(const p of state.projectiles) drawProjectile(p);

  // units: ground then flying
  state.units.filter(u => !u.isFlying).forEach(drawUnit);
  state.units.filter(u => u.isFlying).forEach(drawUnit);

  // preview
  if(state.preview){
    const p = state.preview;
    ctx.beginPath(); ctx.fillStyle = 'rgba(255,210,80,0.12)'; ctx.strokeStyle = 'rgba(255,210,80,0.98)'; ctx.lineWidth = 2;
    ctx.arc(p.x, p.y, p.card.range || 20, 0, Math.PI*2); ctx.fill(); ctx.stroke();
    ctx.beginPath(); ctx.fillStyle = 'rgba(255,210,80,0.98)'; ctx.arc(p.x,p.y,8,0,Math.PI*2); ctx.fill();
    if(p.card.type === 'spell' && p.card.splash) { ctx.beginPath(); ctx.strokeStyle = 'rgba(255,120,40,0.6)'; ctx.setLineDash([6,6]); ctx.arc(p.x,p.y,p.card.splash,0,Math.PI*2); ctx.stroke(); ctx.setLineDash([]); }
  }

  ctx.font = '12px sans-serif'; ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillText(`Elixir: ${Math.floor(state.elixir)} / ${CONFIG.elixir.max}`, 12, 18);
}

function drawTower(t){
  if(!t.alive) return;
  ctx.save(); ctx.translate(t.x,t.y);
  const base = (t.owner === 'player') ? '#dbeeff' : '#ffeaea';
  const accent = (t.owner === 'player') ? 'rgba(47,143,230,0.95)' : 'rgba(226,75,75,0.95)';
  ctx.beginPath(); ctx.fillStyle = base; ctx.arc(0,0,t.r,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.fillStyle = accent; ctx.arc(0,-6,t.r*0.6,0,Math.PI*2); ctx.fill();
  ctx.fillStyle = '#fff'; ctx.fillRect(-10,-t.r-20,20,10);
  const w = 90, h = 8; ctx.fillStyle = '#333'; ctx.fillRect(-w/2, -t.r - 38, w, h);
  ctx.fillStyle = 'var(--hp)'; ctx.fillRect(-w/2, -t.r - 38, w * Math.max(0, t.hp / t.maxHp), h);
  ctx.strokeStyle = 'rgba(0,0,0,0.08)'; ctx.strokeRect(-w/2, -t.r - 38, w, h);
  ctx.fillStyle = '#000'; ctx.font = '12px sans-serif'; ctx.fillText(Math.max(0, Math.round(t.hp)), -10, -t.r - 44);
  ctx.restore();
}
function drawBuilding(b){
  if(!b.alive) return;
  ctx.save(); ctx.translate(b.x,b.y);
  const baseR = b.size || 18;
  ctx.beginPath(); ctx.fillStyle = '#444'; ctx.arc(0,0,baseR+6,0,Math.PI*2); ctx.fill();
  ctx.lineWidth = 3; ctx.strokeStyle = (b.owner==='player') ? 'rgba(47,143,230,0.9)' : 'rgba(226,75,75,0.9)'; ctx.arc(0, 0, baseR+10, 0, Math.PI*2); ctx.stroke();
  const w = baseR*3, h = 8; ctx.fillStyle = '#222'; ctx.fillRect(-w/2, -baseR - 22, w, h);
  ctx.fillStyle = '#34c759'; ctx.fillRect(-w/2, -baseR - 22, w * Math.max(0, b.hp / b.maxHp), h);
  ctx.restore();
}
function drawUnit(u){
  if(u.hp <= 0 || !u) return;
  ctx.save();
  const t = now();
  const bobSpeed = 0.0015 * (u.speed / 60);
  const bob = Math.sin((t - u.spawnTime) * bobSpeed * 1000) * (0.9 + (u.size/12));
  const yOffset = u.isFlying ? -28 + Math.sin((t - u.spawnTime)/300)*4 : 0;
  ctx.translate(u.x, u.y + bob + yOffset);

  ctx.beginPath(); ctx.fillStyle = 'rgba(0,0,0,0.18)';
  ctx.ellipse(0, u.size + 6 + (u.isFlying ? 8 : 0), u.size*1.2, u.size*0.6, 0, 0, Math.PI*2); ctx.fill();

  const r = Math.max(6, u.size);
  ctx.beginPath(); ctx.fillStyle = (u.owner==='player')? '#2f8fe6' : '#e24b4b'; ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
  ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(0,0,0,0.6)'; ctx.stroke();

  const bw = r * 2.4; ctx.fillStyle = 'rgba(0,0,0,0.45)'; ctx.fillRect(-bw/2, -r - 16, bw, 6);
  ctx.fillStyle = 'var(--hp)'; ctx.fillRect(-bw/2, -r - 16, bw * Math.max(0, u.hp / u.maxHp), 6);

  ctx.fillStyle = 'rgba(255,255,255,0.95)';
  ctx.font = `${Math.max(10, r)}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  const sym = u.cardKey === 'knight' ? 'âš”ï¸' : u.cardKey === 'archer' ? 'ðŸ¹' : u.cardKey === 'miniTank' ? 'T' : u.cardKey === 'goblin' ? 'G' : u.cardKey === 'bomber' ? 'ðŸ’£' : u.cardKey === 'healer' ? 'âœš' : u.cardKey === 'skeleton' ? 'â˜ ' : u.cardKey === 'dragon' ? 'ðŸ‰' : (u.name ? u.name[0] : '?');
  ctx.fillText(sym, 0, 0);
  ctx.restore();
}
function drawProjectile(p){
  ctx.save();
  ctx.beginPath();
  ctx.fillStyle = p.color || 'orange';
  const size = Math.max(3, Math.min(12, Math.sqrt(p.dmg || 30)/2));
  ctx.shadowBlur = 12; ctx.shadowColor = ctx.fillStyle;
  ctx.arc(p.x, p.y, size, 0, Math.PI*2); ctx.fill();
  if((p.splash && p.kind === 'spell') || p.kind === 'dragon_proj'){
    ctx.globalAlpha = 0.08; ctx.beginPath(); ctx.fillStyle = p.color; ctx.arc(p.x, p.y, p.splash, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1;
  }
  ctx.shadowBlur = 0;
  ctx.restore();
}

// ---------- MAIN LOOP ----------
function loop(timestamp){
  if(!state) return;
  const dt = timestamp - state.lastFrame; state.lastFrame = timestamp; state.timeMs += dt;

  if(state.running){
    const isDouble = state.timeMs >= CONFIG.elixir.doubleAfterMs;
    const interval = isDouble ? CONFIG.elixir.doubleRegenMs : CONFIG.elixir.regenMs;

    state.elixirTick += dt;
    while(state.elixirTick >= interval){ state.elixirTick -= interval; if(state.elixir < CONFIG.elixir.max) state.elixir++; }
    state.elixir = Math.min(CONFIG.elixir.max, state.elixir);
    updateElixirUI();

    state.cpuElixirTick += dt;
    while(state.cpuElixirTick >= interval){ state.cpuElixirTick -= interval; if(state.cpuElixir < CONFIG.elixir.max) state.cpuElixir++; }
    state.cpuElixir = Math.min(CONFIG.elixir.max, state.cpuElixir);

    cpuBehaviorTick(dt);
    simulate(dt);

    const mm = Math.floor(state.timeMs / 60000);
    const ss = Math.floor((state.timeMs % 60000) / 1000);
    clockEl.textContent = `${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}`;
  }

  render();

  if(state.running) requestAnimationFrame(loop);
}

// ---------- BOOTSTRAP ----------
function logInitialHand(){ const vis = state.playerDeck.slice(0, CONFIG.deckVisible).map(c=>c.name).join(', '); log('Initial hand: ' + vis); }
initGame(); logInitialHand(); renderHand(); requestAnimationFrame(loop);

// ---------- QUICK DEV SPAWNER ----------
setInterval(() => {
  if(!state || !state.running) return;
  if(Math.random() < 0.5 && state.cpuElixir >= 2){
    // cpu spawns a cheap unit occasionally if elixir allows (keeps battle alive)
    const lane = Math.random() < 0.5 ? 'left' : 'right';
    spawnUnit(CATALOG[3], (lane==='left')?CONFIG.leftX:CONFIG.rightX, CONFIG.princessY.cpu + 40, 'cpu', lane);
    state.cpuElixir -= 2;
  }
}, 3000);
</script>
</body>
</html>
