<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Clash Royale 3D Mega Build</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    #ui {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255,255,255,0.85);
      padding: 10px;
      border-radius: 8px;
      display: flex;
      gap: 5px;
      font-family: sans-serif;
    }
    .button {
      padding: 5px 10px;
      background: #ddd;
      border: 1px solid #aaa;
      border-radius: 4px;
      cursor: pointer;
    }
  </style>
  <!-- Three.js core -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.154/build/three.min.js"></script>
  <!-- OrbitControls fix -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.154/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
  <div id="ui">
    <div class="button" id="spawnBlue">Spawn Blue Troop</div>
    <div class="button" id="spawnRed">Spawn Red Troop</div>
    <div class="button" id="reset">Reset</div>
  </div>
  <script>
    // === SETUP ===
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB); // sky blue

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
    // More top-down view
    camera.position.set(0, 180, 80);
    camera.lookAt(0,0,0);

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);

    // === LIGHTS ===
    const ambient = new THREE.AmbientLight(0xffffff, 2.0);
    scene.add(ambient);

    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
    hemiLight.position.set(0, 200, 0);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
    dirLight.position.set(50, 120, 50);
    scene.add(dirLight);

    // === ARENA ===
    const groundGeo = new THREE.PlaneGeometry(200, 120);
    const groundMat = new THREE.MeshPhongMaterial({color: 0x228B22});
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI/2;
    scene.add(ground);

    // River
    const riverGeo = new THREE.PlaneGeometry(200, 20);
    const riverMat = new THREE.MeshPhongMaterial({color: 0x1E90FF});
    const river = new THREE.Mesh(riverGeo, riverMat);
    river.rotation.x = -Math.PI/2;
    scene.add(river);

    // Bridges
    const bridgeGeo = new THREE.BoxGeometry(30,2,10);
    const bridgeMat = new THREE.MeshPhongMaterial({color: 0x8B4513});
    const bridgeLeft = new THREE.Mesh(bridgeGeo, bridgeMat);
    bridgeLeft.position.set(-50,1,0);
    scene.add(bridgeLeft);
    const bridgeRight = new THREE.Mesh(bridgeGeo, bridgeMat);
    bridgeRight.position.set(50,1,0);
    scene.add(bridgeRight);

    // === TOWERS ===
    function createTower(x,z,color){
      const geo = new THREE.CylinderGeometry(5,5,20,16);
      const mat = new THREE.MeshPhongMaterial({color: color});
      const tower = new THREE.Mesh(geo, mat);
      tower.position.set(x,10,z);
      tower.userData = {hp:100, color: color, type:"tower", cooldown:0};
      scene.add(tower);
      return tower;
    }
    const blueLeftTower = createTower(-60,50,0x0000ff);
    const blueRightTower = createTower(60,50,0x0000ff);
    const redLeftTower = createTower(-60,-50,0xff0000);
    const redRightTower = createTower(60,-50,0xff0000);
    const towers = [blueLeftTower, blueRightTower, redLeftTower, redRightTower];

    // === TROOPS ===
    const troops = [];
    const projectiles = [];

    function createTroop(x,z,color){
      const geo = new THREE.SphereGeometry(3,16,16);
      const mat = new THREE.MeshPhongMaterial({color: color});
      const troop = new THREE.Mesh(geo, mat);
      troop.position.set(x,3,z);
      troop.userData = {hp:30, color: color, target:null, type:"troop", cooldown:0};
      scene.add(troop);
      troops.push(troop);
      return troop;
    }

    document.getElementById("spawnBlue").onclick = ()=>createTroop(0,60,0x0000ff);
    document.getElementById("spawnRed").onclick = ()=>createTroop(0,-60,0xff0000);

    document.getElementById("reset").onclick = ()=>{
      while(troops.length>0){
        const t = troops.pop();
        scene.remove(t);
      }
      while(projectiles.length>0){
        const p = projectiles.pop();
        scene.remove(p.mesh);
      }
      towers.forEach(t=>t.userData.hp=100);
    }

    // === UTILS ===
    function distance(a,b){
      return a.position.distanceTo(b.position);
    }

    function shootProjectile(from,to,color){
      const geo = new THREE.SphereGeometry(1,8,8);
      const mat = new THREE.MeshPhongMaterial({color: color});
      const mesh = new THREE.Mesh(geo,mat);
      mesh.position.copy(from.position);
      scene.add(mesh);
      projectiles.push({mesh:mesh, target:to, color:color, speed:1.0, damage:2});
    }

    // === GAME LOOP ===
    function updateGame(){
      // Troops update
      for(let i=0;i<troops.length;i++){
        const troop = troops[i];
        if (!troop.userData.hp || troop.userData.hp <= 0) continue;

        troop.userData.cooldown = Math.max(0, troop.userData.cooldown-1);

        if (troop.userData.target && troop.userData.target.userData.hp > 0){
          const target = troop.userData.target;
          if (distance(troop, target) < 10){
            if (troop.userData.cooldown===0){
              target.userData.hp -= 2;
              troop.userData.cooldown=30;
              if (target.userData.hp <= 0){
                scene.remove(target);
                if (target.userData.type==="troop"){
                  troops.splice(troops.indexOf(target),1);
                }
                troop.userData.target=null;
              }
            }
          } else {
            // move at fixed speed toward target
            const dir = new THREE.Vector3().subVectors(target.position, troop.position).normalize();
            troop.position.add(dir.multiplyScalar(0.1));
          }
        } else {
          // Find nearby enemy troop
          let nearest=null, nearestDist=Infinity;
          for (let j=0;j<troops.length;j++){
            const other = troops[j];
            if (other===troop) continue;
            if (other.userData.color!==troop.userData.color && other.userData.hp>0){
              const d=distance(troop,other);
              if (d<nearestDist){
                nearest=other;
                nearestDist=d;
              }
            }
          }
          if (nearest && nearestDist<15){
            troop.userData.target=nearest;
          } else {
            // March toward nearest enemy tower
            const enemyTowers = towers.filter(t=>t.userData.color!==troop.userData.color && t.userData.hp>0);
            if (enemyTowers.length>0){
              const targetTower=enemyTowers[0];
              if (distance(troop,targetTower)<12){
                troop.userData.target=targetTower;
              } else {
                const dir = new THREE.Vector3().subVectors(targetTower.position, troop.position).normalize();
                troop.position.add(dir.multiplyScalar(0.05)); // slower speed for towers
              }
            }
          }
        }
      }

      // Towers attack
      towers.forEach(tower=>{
        if (tower.userData.hp<=0) return;
        tower.userData.cooldown=Math.max(0,tower.userData.cooldown-1);
        if (tower.userData.cooldown===0){
          let nearest=null,nearestDist=Infinity;
          troops.forEach(t=>{
            if (t.userData.color!==tower.userData.color && t.userData.hp>0){
              const d=distance(t,tower);
              if (d<nearestDist && d<40){
                nearest=t;
                nearestDist=d;
              }
            }
          });
          if (nearest){
            shootProjectile(tower,nearest,tower.userData.color);
            tower.userData.cooldown=60;
          }
        }
      });

      // Projectiles
      for (let i=projectiles.length-1;i>=0;i--){
        const p=projectiles[i];
        if (!p.target || !p.target.userData.hp || p.target.userData.hp<=0){
          scene.remove(p.mesh);
          projectiles.splice(i,1);
          continue;
        }
        p.mesh.position.lerp(p.target.position,0.1*p.speed);
        if (distance(p.mesh,p.target)<2){
          p.target.userData.hp-=p.damage;
          if (p.target.userData.hp<=0){
            scene.remove(p.target);
            if (p.target.userData.type==="troop"){
              troops.splice(troops.indexOf(p.target),1);
            }
          }
          scene.remove(p.mesh);
          projectiles.splice(i,1);
        }
      }
    }

    function animate(){
      requestAnimationFrame(animate);
      try{
        updateGame();
      }catch(e){
        console.error("Game loop error:",e);
      }
      renderer.render(scene,camera);
    }
    animate();

    window.addEventListener("resize",()=>{
      camera.aspect=window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth,window.innerHeight);
    });
  </script>
</body>
</html>
